/*! For license information please see appless-mobile.min.js.LICENSE.txt */
(()=>{"use strict";var e={d:(t,r)=>{for(var a in r)e.o(r,a)&&!e.o(t,a)&&Object.defineProperty(t,a,{enumerable:!0,get:r[a]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t)},t={};e.d(t,{default:()=>o});class r{#e;constructor(){if("undefined"==typeof window&&"undefined"==typeof self)this.#t();else try{this.#e=window?.crypto,this.#e.CryptoKey=window?.CryptoKey}catch(e){this.#e=self?.crypto,this.#e.CryptoKey=self?.CryptoKey}}#t=async()=>{this.#e=await Object.getPrototypeOf((async function(){})).constructor('\n      return await import( "crypto" ).then((m) => {return m.default.webcrypto});\n')()};#r=async e=>{await new Promise(((t,r)=>{setTimeout((()=>t(!0)),e)}))};base64ToArray(e){return Uint8Array.from(atob(e),(e=>e.charCodeAt(0)))}arrayToBase64(e){return btoa(String.fromCharCode(...e))}HMAC=async(e,t)=>{await this.#r(0);let r=new TextEncoder("utf-8"),a=r.encode(e),i=r.encode(t),s=await this.#e.subtle.importKey("raw",a,{name:"HMAC",hash:{name:"SHA-256"}},!1,["sign","verify"]),n=await this.#e.subtle.sign("HMAC",s,i),o=new Uint8Array(n);return Array.prototype.map.call(o,(e=>("00"+e.toString(16)).slice(-2))).join("")};HASH=async(e,t,r)=>{await this.#r(0);let a,i=await this.#e.subtle.digest(e,(new TextEncoder).encode(t)),s=new Uint8Array(i);if(r){a=new Uint8Array(r,0),Math.min(r,s.length);let e=Math.max(r,s.length);for(var n=0;n<e;n++)a[n%r]=a[n%r]^s[n%s.length]}else a=s;return this.arrayToBase64(new Uint8Array(a))};PASSWORD_ENCRYPT=async(e,t)=>{await this.#r(0);for(let t=0;t<1e4;t++)e=this.HASH("SHA-512",e);let r=btoa(e),a=await this.AESMakeKey(!0),i=await this.AESEncrypt(a,t,r);return btoa(JSON.stringify({ciphertext:i.ciphertext,aes:a}))};PASSWORD_DECRYPT=async(e,t)=>{await this.#r(0);for(let t=0;t<1e4;t++)e=this.HASH("SHA-512",e);let r=btoa(e),a=JSON.parse(atob(t)),i=await this.AESImportKey(a.aes,!1),s=a.ciphertext;return await this.AESDecrypt(i,r,s,!0)};AESMakeKey=async(e=!0)=>{await this.#r(0);let t=await this.#e.subtle.generateKey({name:"AES-GCM",length:256},e,["encrypt","decrypt"]);if(e){let e=await this.#e.subtle.exportKey("raw",t);return this.arrayToBase64(new Uint8Array(e))}return t};AESImportKey=async(e,t=!0)=>(await this.#r(0),e instanceof this.#e.CryptoKey?e:await this.#e.subtle.importKey("raw",this.base64ToArray(e).buffer,"AES-GCM",t,["encrypt","decrypt"]));async AESEncrypt(e,t,r=!1){await this.#r(0);let a,i=await this.AESImportKey(e);a=r?this.base64ToArray(r):this.#e.getRandomValues(new Uint8Array(16));let s=await this.#e.subtle.encrypt({name:"AES-GCM",iv:a},i,this.base64ToArray(t));return{ciphertext:this.arrayToBase64(new Uint8Array(s)),iv:this.arrayToBase64(a)}}async AESDecrypt(e,t,r,a=!1){await this.#r(0);let i,s=await this.AESImportKey(e),n=this.base64ToArray(t),o=this.base64ToArray(r);return i=await this.#e.subtle.decrypt({name:"AES-GCM",iv:n},s,o),a?(i=new Uint8Array(i),i=(new TextDecoder).decode(i),i):i}EcMakeCryptKeys=async(e=!0)=>{await this.#r(0);let t,r=await this.#e.subtle.generateKey({name:"ECDH",namedCurve:"P-256"},e,["deriveKey","deriveBits"]);return t=e?await Promise.all([this.#e.subtle.exportKey("spki",r.publicKey).then((e=>this.arrayToBase64(new Uint8Array(e)))),this.#e.subtle.exportKey("pkcs8",r.privateKey).then((e=>this.arrayToBase64(new Uint8Array(e)))),this.#e.subtle.exportKey("jwk",r.publicKey).then((e=>e)),this.#e.subtle.exportKey("jwk",r.privateKey).then((e=>e)),this.#e.subtle.exportKey("raw",r.publicKey).then((e=>this.arrayToBase64(new Uint8Array(e)))),this.#e.subtle.exportKey("raw",r.publicKey).then((e=>this.arrayToBase64(new Uint8Array(e).slice(1,1e3))))]):await Promise.all([this.#e.subtle.exportKey("spki",r.publicKey).then((e=>this.arrayToBase64(new Uint8Array(e)))),new Promise(((e,t)=>e(r.privateKey))),this.#e.subtle.exportKey("raw",r.publicKey).then((e=>this.arrayToBase64(new Uint8Array(e)))),this.#e.subtle.exportKey("raw",r.publicKey).then((e=>this.arrayToBase64(new Uint8Array(e).slice(1,1e3))))]),e?{publicKey:t[0],privateKey:t[1],jwkPublicKey:t[2],jwkPrivateKey:t[3],rawPublicKey:t[4],rawPublicKeyLite:t[5]}:{publicKey:t[0],privateKey:t[1],rawPublicKey:t[2],rawPublicKeyLite:t[3]}};EcEncrypt=async(e,t,r)=>{await this.#r(0);let a=await this.EcdhConvertKey(t),i=await this.EcdhConvertKey(e);return await this.#e.subtle.deriveKey({name:"ECDH",public:a},i,{name:"AES-GCM",length:256},!1,["encrypt","decrypt"]),await this.AESEncrypt(b64_aes_key,r)};EcDecrypt=async(e,t,r,a)=>{let i=await this.EcdhConvertKey(t),s=await this.EcdhConvertKey(e),n=this.base64ToArray(r),o=this.base64ToArray(a),c=await this.#e.subtle.deriveKey({name:"ECDH",public:i},s,{name:"AES-GCM",length:256},!1,["encrypt","decrypt"]);return await this.#e.subtle.decrypt({name:"AES-GCM",iv:n},c,o)};HKDFEncrypt=async(e,t,r)=>{await this.#r(0);let a=await this.EcdhConvertKey(t),i=await this.EcdhConvertKey(e),s=await this.#e.subtle.deriveBits({name:"ECDH",namedCurve:"P-256",public:a},i,256),n=await this.#e.subtle.importKey("raw",s,{name:"HKDF"},!1,["deriveKey","deriveBits"]),o=this.#e.getRandomValues(new Uint8Array(16)),c=await this.#e.subtle.deriveBits({name:"HKDF",hash:"SHA-256",salt:o,info:new Uint8Array([])},n,256),y=await this.#e.subtle.importKey("raw",c,"AES-GCM",!1,["encrypt","decrypt"]),l=this.#e.getRandomValues(new Uint8Array(16)),h=await this.#e.subtle.encrypt({name:"AES-GCM",iv:l},y,this.base64ToArray(r));return{ciphertext:this.arrayToBase64(new Uint8Array(h)),salt:this.arrayToBase64(o),iv:this.arrayToBase64(l)}};HKDFDecrypt=async(e,t,r,a,i)=>{await this.#r(0);let s,n=await this.EcdhConvertKey(t),o=await this.EcdhConvertKey(e),c=this.base64ToArray(r),y=this.base64ToArray(a),l=this.base64ToArray(i),h=await this.#e.subtle.deriveBits({name:"ECDH",namedCurve:"P-256",public:n},o,256),p=await this.#e.subtle.importKey("raw",h,{name:"HKDF"},!1,["deriveKey","deriveBits"]),w=await this.#e.subtle.deriveBits({name:"HKDF",hash:"SHA-256",salt:c,info:new Uint8Array([])},p,256),u=await this.#e.subtle.importKey("raw",w,"AES-GCM",!1,["encrypt","decrypt"]);try{s=await this.#e.subtle.decrypt({name:"AES-GCM",iv:y},u,l)}catch(e){console.log({name:e.name,stack:e.stack,message:e.message})}return s};EcMakeSigKeys=async(e=!0)=>{await this.#r(0);let t,r=await this.#e.subtle.generateKey({name:"ECDSA",namedCurve:"P-256"},e,["sign","verify"]);return e?(t=await Promise.all([this.#e.subtle.exportKey("spki",r.publicKey).then((e=>this.arrayToBase64(new Uint8Array(e)))),this.#e.subtle.exportKey("pkcs8",r.privateKey).then((e=>this.arrayToBase64(new Uint8Array(e))))]),{publicKey:t[0],privateKey:t[1]}):(t=await Promise.all([this.#e.subtle.exportKey("spki",r.publicKey).then((e=>this.arrayToBase64(new Uint8Array(e))))]),{publicKey:t[0],privateKey:r.privateKey})};EcSignData=async(e,t)=>{await this.#r(0);let r=await this.EcdsaConvertKey(e),a=await this.#e.subtle.sign({name:"ECDSA",hash:{name:"SHA-256"}},r,this.base64ToArray(t));return await this.arrayToBase64(new Uint8Array(a))};EcVerifySig=async(e,t,r)=>{await this.#r(0);let a=await this.EcdsaConvertKey(e),i=this.base64ToArray(t);return await this.#e.subtle.verify({name:"ECDSA",hash:{name:"SHA-256"}},a,i,this.base64ToArray(r))};EcdhConvertKey=async e=>{let t,r;if(await this.#r(0),e instanceof this.#e.CryptoKey)return e;try{return t=await this.#e.subtle.importKey("spki",this.base64ToArray(e),{name:"ECDH",namedCurve:"P-256"},!0,[]),t}catch(e){}try{return t=await this.#e.subtle.importKey("raw",this.base64ToArray(e),{name:"ECDH",namedCurve:"P-256"},!0,[]),t}catch(e){}try{return t=await this.#e.subtle.importKey("pkcs8",this.base64ToArray(e),{name:"ECDH",namedCurve:"P-256"},!1,["deriveKey","deriveBits"]),t}catch(e){}try{return r=new Uint8Array([4].concat(Array.from(this.base64ToArray(e)))),t=await this.#e.subtle.importKey("raw",r,{name:"ECDH",namedCurve:"P-256"},!0,[]),t}catch(e){throw new Error("UNRECOGNIZED KEY FORMAT")}};EcdsaConvertKey=async e=>{let t,r;if(await this.#r(0),e instanceof this.#e.CryptoKey)return e;try{return t=await this.#e.subtle.importKey("spki",this.base64ToArray(e),{name:"ECDSA",namedCurve:"P-256"},!0,["verify"]),t}catch(e){}try{return t=await this.#e.subtle.importKey("raw",this.base64ToArray(e),{name:"ECDSA",namedCurve:"P-256"},!0,["verify"]),t}catch(e){}try{return t=await this.#e.subtle.importKey("pkcs8",this.base64ToArray(e),{name:"ECDSA",namedCurve:"P-256"},!1,["sign"]),t}catch(e){}try{return r=new Uint8Array([4].concat(Array.from(this.base64ToArray(e)))),t=await this.#e.subtle.importKey("raw",r,{name:"ECDSA",namedCurve:"P-256"},!0,["sign"]),t}catch(e){throw new Error("UNRECOGNIZED KEY FORMAT")}}}class a{#a;#i;start=async(e,t,r)=>new Promise(((a,i)=>{try{const s=indexedDB.open(e,1);s.onerror=e=>{i(e)},s.onupgradeneeded=async e=>{this.#a=e.target.result;const a=this.#a.createObjectStore(t,{keyPath:"id"});r&&await Promise.all(r.map((e=>a.createIndex(e,e))))},s.onsuccess=e=>{this.#a=e.target.result,a(!0)}}catch(e){i(e)}}));#s=async e=>(await this.#a.transaction(e,"readwrite")).objectStore(e);creates=async(e,t)=>{const r=await this.#s(e);let a;try{return a=await r.add(t),await new Promise(((e,t)=>{a.onsuccess=()=>e(!0),a.onerror=e=>{throw new Error(e)}})),a.result}catch(e){return e}};reads=async(e,t)=>{const r=await this.#s(e);let a;try{return a=await r.get(t),await new Promise(((e,t)=>{a.onsuccess=()=>e(!0),a.onerror=e=>{throw new Error(e)}})),a.result}catch(e){return e}};updates=async(e,t)=>{if(!await this.reads(e,t.id))throw new Error("A record must exist before you can update it");const r=await this.#s(e);let a;try{return a=await r.put(t),await new Promise(((e,t)=>{a.onsuccess=()=>e(!0),a.onerror=e=>{throw new Error(e)}})),a.result}catch(e){return e}};deletes=async(e,t)=>{const r=await this.#s(e);let a;try{return a=await r.delete(t),await new Promise(((e,t)=>{a.onsuccess=()=>e(!0),a.onerror=e=>{throw new Error(e)}})),a.result}catch(e){return e}};searches=async(e,t,r)=>{const a=await this.#s(e);let i;try{let e=a.index(t);return i=await e.getAll(r),await new Promise(((e,t)=>{i.onsuccess=()=>e(!0),i.onerror=e=>{throw console.log({e}),new Error(e)}})),i.result}catch(e){return e}}}class i{#n=e=>(new TextEncoder).encode(e);#o=e=>new TextDecoder("utf-8").decode(e);#c=e=>{const t=new Uint8Array(e);let r="";for(const e of t)r+=String.fromCharCode(e);return btoa(r).replace(/\+/g,"-").replace(/\//g,"_").replace(/=/g,"")};#y=e=>{const t=e.replace(/-/g,"+").replace(/_/g,"/"),r=(4-t.length%4)%4,a=t.padEnd(t.length+r,"="),i=atob(a),s=new ArrayBuffer(i.length),n=new Uint8Array(s);for(let e=0;e<i.length;e++)n[e]=i.charCodeAt(e);return s};#l=()=>void 0!==(null===window||void 0===window?void 0:window.PublicKeyCredential)&&"function"==typeof window.PublicKeyCredential;#h=e=>{const{id:t}=e;return{...e,id:this.#y(t)}};priv={};async startRegistration(e){var t=this;if(!t.#l())throw new Error("WebAuthn is not supported in this browser");let r={...e,challenge:t.#y(e.challenge),user:{...e.user,id:t.#n(e.user.id)},excludeCredentials:e.excludeCredentials.map(this.#h)};const a=await navigator.credentials.create({publicKey:r});if(!a)throw new Error("Registration was not completed");const{id:i,rawId:s,response:n,type:o}=a,c={id:i,rawId:t.#c(s),response:{attestationObject:t.#c(n.attestationObject),clientDataJSON:t.#c(n.clientDataJSON)},type:o,clientExtensionResults:a.getClientExtensionResults()};return"function"==typeof n.getTransports&&(c.transports=n.getTransports()),c}async startAuthentication(e){var t,r,a=this;if(!a.#l())throw new Error("WebAuthn is not supported in this browser");let i;0!==(null===(t=e.allowCredentials)||void 0===t?void 0:t.length)&&(i=null===(r=e.allowCredentials)||void 0===r?void 0:r.map((e=>this.#h(e))));const s={...e,challenge:a.#y(e.challenge),allowCredentials:i},n=await navigator.credentials.get({publicKey:s});if(!n)throw new Error("Authentication was not completed");const{id:o,rawId:c,response:y,type:l}=n;let h;return y.userHandle&&(h=a.#o(y.userHandle)),{id:o,rawId:a.#c(c),response:{authenticatorData:a.#c(y.authenticatorData),clientDataJSON:a.#c(y.clientDataJSON),signature:a.#c(y.signature),userHandle:h},type:l,clientExtensionResults:n.getClientExtensionResults()}}async platformAuthenticatorIsAvailable(){return!!browserSupportsWebauthn()&&PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable()}}async function s(e,t,a,i,s,n){const o=new r;let c={apiData:{associationKey:"WEBSOCKET-TEST-SCRIPT",publicUserId:"public-User-ID"},browserData:{...await o.HKDFEncrypt(t,i.browserPublicKey,btoa(JSON.stringify(e))),publicKey:a},errorMsg:"",errors:!1},y={mode:"cors",method:"POST",body:JSON.stringify({...c,__salt:i.__salt,__hash:i.__hash})};await fetch(`https://${n}.api.keyri.com/api/v1/session/${s}`,y).then((async e=>await e.json())),window.close()}async function n(e,t,a,n,o,c){const y=new r;let l=btoa(JSON.stringify({timestamp:(new Date).getTime(),publicKey:t.signingKeys.publicKey})),h=await y.EcSignData(t.signingKeys.privateKey,l),p={challenge:btoa(JSON.stringify({data:l,signature:h,publicKey:t.signingKeys.publicKey})),rpId:document.location.host,userVerification:"discouraged",attestation:!1,timeout:6e4,requireResidentKey:!0};window.focus();const w=new i,u=await w.startAuthentication(p);let d=await fetch("https://c4xfkg8ea4.execute-api.us-east-2.amazonaws.com/prod/v1/browser/verify/",{method:"POST",mode:"cors",headers:{"Content-Type":"application/json"},body:JSON.stringify(u)}).then((async e=>await e.json()));if(c)return d;d.validationFormat="keyri-appless",await s(d,t.encryptionKeys.privateKey,t.encryptionKeys.publicKey,n,a,o)}class o{#a;#p;#w;#u;#d=!1;#e;#b;#K;#m={signingKeys:{},encryptionKeys:{}};constructor(e){this.#p=e,this.#a=new a,this.#e=new r,this.#u=new EventTarget}on=(e,t)=>{this.#u.addEventListener(e,t)};#g=(e,t)=>{this.#u.dispatchEvent(new CustomEvent(e,{detail:t}))};register=async(e=!1)=>await this.#f({registration:e});authenticate=async()=>{try{return await n()}catch(e){console.log({ERROR:e})}};set passwordHandler(e){this.#K=e}start=async(e=!1)=>{this.#d=e;const{signingKeys:t,encryptionKeys:i}=await async function(){let e,t,i=new a,s=new r;await i.start("mobile","credentials");try{e=await i.reads("credentials","signingKeys"),t=await i.reads("credentials","encryptionKeys")}catch(e){throw new Error(e)}if(void 0===e){e=await s.EcMakeSigKeys(!1),e.id="signingKeys",t=await s.EcMakeCryptKeys(!1),t.id="encryptionKeys";try{await i.creates("credentials",e),await i.creates("credentials",t)}catch(e){throw new Error(e)}}return{signingKeys:e,encryptionKeys:t}}();if(this.#m.signingKeys=t,this.#m.encryptionKeys=i,!this.#d){const{sessionData:r,sessionId:a,userParameters:i}=await async function(e,t){let r,a,i=Object.fromEntries(Array.from(new URL(document.location).searchParams)).sessionId;if(!i)throw new Error("No Session Id Provided");let s={mode:"cors",method:"GET",headers:new Headers({"x-mobile-id":e})},n=`https://${t}.api.keyri.com/api/v1/session/${i}`;if(r=await fetch(n,s),!1===r?.ok)throw r=await r.json(),new Error(r.message);return r=await r.json(),a=atob(r?.userParameters?.base64EncodedData),a=JSON.parse(a),{sessionData:r,userParameters:a,sessionId:i}}(t.publicKey,this.#p);if(this.#w=a,this.#b=r,"true"==i?.register)return await this.#f(i);try{return await n(0,this.#m,a,r,this.#p,e)}catch(e){console.log({ERROR:e})}}};#f=async e=>{let t,r=e.registration;t=this.#K?await this.#K():"";try{e.registration=await this.#e.PASSWORD_DECRYPT(t,r.data)}catch(e){throw console.log("DATA DECRYPTION FAILED. WOMP WOMP!",{e}),new Error("PASSWORD DECRYPTION FAILED.")}let a=JSON.parse(e.registration),n=JSON.parse(atob(a.data)),o=JSON.parse(atob(n.child.data)),c=JSON.parse(atob(o.child.data)),y={child:a,publicKey:this.#m.signingKeys.publicKey,timestamp:(new Date).getTime()};y=btoa(JSON.stringify(y));let l=await this.#e.EcSignData(this.#m.signingKeys.privateKey,y),h=JSON.stringify({data:y,signature:l});console.log({userParameters:e,mobileData:y,browserTwo:n,rpData:o,browserData:c}),e.registration=btoa(h);let p={challenge:e.registration,rp:{name:o.origin,id:o.origin},user:{id:o.userId,name:o.userDisplayName,displayName:o.userDisplayName},pubKeyCredParams:[{alg:-7,type:"public-key"},{alg:-257,type:"public-key"}],timeout:6e4,attestation:"none",excludeCredentials:[],authenticatorSelection:{requireResidentKey:!0,userVerification:"discouraged"}};return await async function(e,t,r,a,n,o){{const c=new i;window.focus();let y=e.userParameters,l=e?.authoptions,h=await c.startRegistration(l),p=await fetch("https://c4xfkg8ea4.execute-api.us-east-2.amazonaws.com/prod/v1/browser/register/",{method:"POST",mode:"cors",headers:{"Content-Type":"application/json"},body:JSON.stringify({authenticatorData:h,userParameters:y})}).then((async e=>await e.json()));if(o)return p;await s(p,t.encryptionKeys.privateKey,t.encryptionKeys.publicKey,r,a,n)}}({authoptions:p,userParameters:e},this.#m,this.#b,this.#w,this.#p,this.#d)}}window.ApplessMobile=t.default})();
//# sourceMappingURL=appless-mobile.min.js.map
/*! For license information please see appless-local.min.js.LICENSE.txt */
(()=>{"use strict";var t={d:(e,a)=>{for(var r in a)t.o(a,r)&&!t.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:a[r]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e)},e={};t.d(e,{default:()=>y});class a{#t;constructor(){if("undefined"==typeof window&&"undefined"==typeof self)this.#e();else try{this.#t=window?.crypto,this.#t.CryptoKey=window?.CryptoKey}catch(t){this.#t=self?.crypto,this.#t.CryptoKey=self?.CryptoKey}}#e=async()=>{this.#t=await Object.getPrototypeOf((async function(){})).constructor('\n      return await import( "crypto" ).then((m) => {return m.default.webcrypto});\n')()};#a=async t=>{await new Promise(((e,a)=>{setTimeout((()=>e(!0)),t)}))};base64ToArray(t){return Uint8Array.from(atob(t),(t=>t.charCodeAt(0)))}arrayToBase64(t){return btoa(String.fromCharCode(...t))}HMAC=async(t,e)=>{await this.#a(0);let a=new TextEncoder("utf-8"),r=a.encode(t),s=a.encode(e),i=await this.#t.subtle.importKey("raw",r,{name:"HMAC",hash:{name:"SHA-256"}},!1,["sign","verify"]),n=await this.#t.subtle.sign("HMAC",i,s),o=new Uint8Array(n);return Array.prototype.map.call(o,(t=>("00"+t.toString(16)).slice(-2))).join("")};HASH=async(t,e,a)=>{await this.#a(0);let r,s=await this.#t.subtle.digest(t,(new TextEncoder).encode(e)),i=new Uint8Array(s);if(a){r=new Uint8Array(a,0),Math.min(a,i.length);let t=Math.max(a,i.length);for(var n=0;n<t;n++)r[n%a]=r[n%a]^i[n%i.length]}else r=i;return this.arrayToBase64(new Uint8Array(r))};PASSWORD_ENCRYPT=async(t,e)=>{await this.#a(0);for(let e=0;e<1e4;e++)t=this.HASH("SHA-512",t);let a=btoa(t),r=await this.AESMakeKey(!0),s=await this.AESEncrypt(r,e,a);return btoa(JSON.stringify({ciphertext:s.ciphertext,aes:r}))};PASSWORD_DECRYPT=async(t,e)=>{await this.#a(0);for(let e=0;e<1e4;e++)t=this.HASH("SHA-512",t);let a=btoa(t),r=JSON.parse(atob(e)),s=await this.AESImportKey(r.aes,!1),i=r.ciphertext;return await this.AESDecrypt(s,a,i,!0)};AESMakeKey=async(t=!0)=>{await this.#a(0);let e=await this.#t.subtle.generateKey({name:"AES-GCM",length:256},t,["encrypt","decrypt"]);if(t){let t=await this.#t.subtle.exportKey("raw",e);return this.arrayToBase64(new Uint8Array(t))}return e};AESImportKey=async(t,e=!0)=>(await this.#a(0),t instanceof this.#t.CryptoKey?t:await this.#t.subtle.importKey("raw",this.base64ToArray(t).buffer,"AES-GCM",e,["encrypt","decrypt"]));async AESEncrypt(t,e,a=!1){await this.#a(0);let r,s=await this.AESImportKey(t);r=a?this.base64ToArray(a):this.#t.getRandomValues(new Uint8Array(16));let i=await this.#t.subtle.encrypt({name:"AES-GCM",iv:r},s,this.base64ToArray(e));return{ciphertext:this.arrayToBase64(new Uint8Array(i)),iv:this.arrayToBase64(r)}}async AESDecrypt(t,e,a,r=!1){await this.#a(0);let s,i=await this.AESImportKey(t),n=this.base64ToArray(e),o=this.base64ToArray(a);return s=await this.#t.subtle.decrypt({name:"AES-GCM",iv:n},i,o),r?(s=new Uint8Array(s),s=(new TextDecoder).decode(s),s):s}EcMakeCryptKeys=async(t=!0)=>{await this.#a(0);let e,a=await this.#t.subtle.generateKey({name:"ECDH",namedCurve:"P-256"},t,["deriveKey","deriveBits"]);return e=t?await Promise.all([this.#t.subtle.exportKey("spki",a.publicKey).then((t=>this.arrayToBase64(new Uint8Array(t)))),this.#t.subtle.exportKey("pkcs8",a.privateKey).then((t=>this.arrayToBase64(new Uint8Array(t)))),this.#t.subtle.exportKey("jwk",a.publicKey).then((t=>t)),this.#t.subtle.exportKey("jwk",a.privateKey).then((t=>t)),this.#t.subtle.exportKey("raw",a.publicKey).then((t=>this.arrayToBase64(new Uint8Array(t)))),this.#t.subtle.exportKey("raw",a.publicKey).then((t=>this.arrayToBase64(new Uint8Array(t).slice(1,1e3))))]):await Promise.all([this.#t.subtle.exportKey("spki",a.publicKey).then((t=>this.arrayToBase64(new Uint8Array(t)))),new Promise(((t,e)=>t(a.privateKey))),this.#t.subtle.exportKey("raw",a.publicKey).then((t=>this.arrayToBase64(new Uint8Array(t)))),this.#t.subtle.exportKey("raw",a.publicKey).then((t=>this.arrayToBase64(new Uint8Array(t).slice(1,1e3))))]),t?{publicKey:e[0],privateKey:e[1],jwkPublicKey:e[2],jwkPrivateKey:e[3],rawPublicKey:e[4],rawPublicKeyLite:e[5]}:{publicKey:e[0],privateKey:e[1],rawPublicKey:e[2],rawPublicKeyLite:e[3]}};EcEncrypt=async(t,e,a)=>{await this.#a(0);let r=await this.EcdhConvertKey(e),s=await this.EcdhConvertKey(t);return await this.#t.subtle.deriveKey({name:"ECDH",public:r},s,{name:"AES-GCM",length:256},!1,["encrypt","decrypt"]),await this.AESEncrypt(b64_aes_key,a)};EcDecrypt=async(t,e,a,r)=>{let s=await this.EcdhConvertKey(e),i=await this.EcdhConvertKey(t),n=this.base64ToArray(a),o=this.base64ToArray(r),c=await this.#t.subtle.deriveKey({name:"ECDH",public:s},i,{name:"AES-GCM",length:256},!1,["encrypt","decrypt"]);return await this.#t.subtle.decrypt({name:"AES-GCM",iv:n},c,o)};HKDFEncrypt=async(t,e,a)=>{await this.#a(0);let r=await this.EcdhConvertKey(e),s=await this.EcdhConvertKey(t),i=await this.#t.subtle.deriveBits({name:"ECDH",namedCurve:"P-256",public:r},s,256),n=await this.#t.subtle.importKey("raw",i,{name:"HKDF"},!1,["deriveKey","deriveBits"]),o=this.#t.getRandomValues(new Uint8Array(16)),c=await this.#t.subtle.deriveBits({name:"HKDF",hash:"SHA-256",salt:o,info:new Uint8Array([])},n,256),y=await this.#t.subtle.importKey("raw",c,"AES-GCM",!1,["encrypt","decrypt"]),h=this.#t.getRandomValues(new Uint8Array(16)),l=await this.#t.subtle.encrypt({name:"AES-GCM",iv:h},y,this.base64ToArray(a));return{ciphertext:this.arrayToBase64(new Uint8Array(l)),salt:this.arrayToBase64(o),iv:this.arrayToBase64(h)}};HKDFDecrypt=async(t,e,a,r,s)=>{await this.#a(0);let i,n=await this.EcdhConvertKey(e),o=await this.EcdhConvertKey(t),c=this.base64ToArray(a),y=this.base64ToArray(r),h=this.base64ToArray(s),l=await this.#t.subtle.deriveBits({name:"ECDH",namedCurve:"P-256",public:n},o,256),p=await this.#t.subtle.importKey("raw",l,{name:"HKDF"},!1,["deriveKey","deriveBits"]),w=await this.#t.subtle.deriveBits({name:"HKDF",hash:"SHA-256",salt:c,info:new Uint8Array([])},p,256),u=await this.#t.subtle.importKey("raw",w,"AES-GCM",!1,["encrypt","decrypt"]);try{i=await this.#t.subtle.decrypt({name:"AES-GCM",iv:y},u,h)}catch(t){console.log({name:t.name,stack:t.stack,message:t.message})}return i};EcMakeSigKeys=async(t=!0)=>{await this.#a(0);let e,a=await this.#t.subtle.generateKey({name:"ECDSA",namedCurve:"P-256"},t,["sign","verify"]);return t?(e=await Promise.all([this.#t.subtle.exportKey("spki",a.publicKey).then((t=>this.arrayToBase64(new Uint8Array(t)))),this.#t.subtle.exportKey("pkcs8",a.privateKey).then((t=>this.arrayToBase64(new Uint8Array(t))))]),{publicKey:e[0],privateKey:e[1]}):(e=await Promise.all([this.#t.subtle.exportKey("spki",a.publicKey).then((t=>this.arrayToBase64(new Uint8Array(t))))]),{publicKey:e[0],privateKey:a.privateKey})};EcSignData=async(t,e)=>{await this.#a(0);let a=await this.EcdsaConvertKey(t),r=await this.#t.subtle.sign({name:"ECDSA",hash:{name:"SHA-256"}},a,this.base64ToArray(e));return await this.arrayToBase64(new Uint8Array(r))};EcVerifySig=async(t,e,a)=>{await this.#a(0);let r=await this.EcdsaConvertKey(t),s=this.base64ToArray(e);return await this.#t.subtle.verify({name:"ECDSA",hash:{name:"SHA-256"}},r,s,this.base64ToArray(a))};EcdhConvertKey=async t=>{let e,a;if(await this.#a(0),t instanceof this.#t.CryptoKey)return t;try{return e=await this.#t.subtle.importKey("spki",this.base64ToArray(t),{name:"ECDH",namedCurve:"P-256"},!0,[]),e}catch(t){}try{return e=await this.#t.subtle.importKey("raw",this.base64ToArray(t),{name:"ECDH",namedCurve:"P-256"},!0,[]),e}catch(t){}try{return e=await this.#t.subtle.importKey("pkcs8",this.base64ToArray(t),{name:"ECDH",namedCurve:"P-256"},!1,["deriveKey","deriveBits"]),e}catch(t){}try{return a=new Uint8Array([4].concat(Array.from(this.base64ToArray(t)))),e=await this.#t.subtle.importKey("raw",a,{name:"ECDH",namedCurve:"P-256"},!0,[]),e}catch(t){throw new Error("UNRECOGNIZED KEY FORMAT")}};EcdsaConvertKey=async t=>{let e,a;if(await this.#a(0),t instanceof this.#t.CryptoKey)return t;try{return e=await this.#t.subtle.importKey("spki",this.base64ToArray(t),{name:"ECDSA",namedCurve:"P-256"},!0,["verify"]),e}catch(t){}try{return e=await this.#t.subtle.importKey("raw",this.base64ToArray(t),{name:"ECDSA",namedCurve:"P-256"},!0,["verify"]),e}catch(t){}try{return e=await this.#t.subtle.importKey("pkcs8",this.base64ToArray(t),{name:"ECDSA",namedCurve:"P-256"},!1,["sign"]),e}catch(t){}try{return a=new Uint8Array([4].concat(Array.from(this.base64ToArray(t)))),e=await this.#t.subtle.importKey("raw",a,{name:"ECDSA",namedCurve:"P-256"},!0,["sign"]),e}catch(t){throw new Error("UNRECOGNIZED KEY FORMAT")}}}class r{register=async(t,e,r)=>{r||(r="");const s=new a,i=await s.EcMakeSigKeys(!1);let n=await(async(t,e)=>{const r=new a;let s=(new Date).getTime().toString(),i=t.publicKey,n=btoa(JSON.stringify({timestamp:s,publicKey:i,metadata:e})),o=await r.EcSignData(t.privateKey,n);return JSON.stringify({data:n,signature:o})})(i,e),o={method:"POST",headers:{"content-type":"application/json"},body:n},c=await fetch(t,o).then((async t=>t.json())),y=await(async(t,e)=>{const r=new a;let s=(new Date).getTime().toString(),i=t.publicKey,n=btoa(JSON.stringify({timestamp:s,publicKey:i,child:e}));return{data:n,signature:await r.EcSignData(t.privateKey,n)}})(i,c);return y=btoa(JSON.stringify(y)),y=await s.PASSWORD_ENCRYPT(r,y),console.log({encrypted:!0,data:y}),{encrypted:!0,data:y}}}class s{#r;#s;start=async(t,e,a)=>new Promise(((r,s)=>{try{const i=indexedDB.open(t,1);i.onerror=t=>{s(t)},i.onupgradeneeded=async t=>{this.#r=t.target.result;const r=this.#r.createObjectStore(e,{keyPath:"id"});a&&await Promise.all(a.map((t=>r.createIndex(t,t))))},i.onsuccess=t=>{this.#r=t.target.result,r(!0)}}catch(t){s(t)}}));#i=async t=>(await this.#r.transaction(t,"readwrite")).objectStore(t);creates=async(t,e)=>{const a=await this.#i(t);let r;try{return r=await a.add(e),await new Promise(((t,e)=>{r.onsuccess=()=>t(!0),r.onerror=t=>{throw new Error(t)}})),r.result}catch(t){return t}};reads=async(t,e)=>{const a=await this.#i(t);let r;try{return r=await a.get(e),await new Promise(((t,e)=>{r.onsuccess=()=>t(!0),r.onerror=t=>{throw new Error(t)}})),r.result}catch(t){return t}};updates=async(t,e)=>{if(!await this.reads(t,e.id))throw new Error("A record must exist before you can update it");const a=await this.#i(t);let r;try{return r=await a.put(e),await new Promise(((t,e)=>{r.onsuccess=()=>t(!0),r.onerror=t=>{throw new Error(t)}})),r.result}catch(t){return t}};deletes=async(t,e)=>{const a=await this.#i(t);let r;try{return r=await a.delete(e),await new Promise(((t,e)=>{r.onsuccess=()=>t(!0),r.onerror=t=>{throw new Error(t)}})),r.result}catch(t){return t}};searches=async(t,e,a)=>{const r=await this.#i(t);let s;try{let t=r.index(e);return s=await t.getAll(a),await new Promise(((t,e)=>{s.onsuccess=()=>t(!0),s.onerror=t=>{throw console.log({e:t}),new Error(t)}})),s.result}catch(t){return t}}}class i{#n=t=>(new TextEncoder).encode(t);#o=t=>new TextDecoder("utf-8").decode(t);#c=t=>{const e=new Uint8Array(t);let a="";for(const t of e)a+=String.fromCharCode(t);return btoa(a).replace(/\+/g,"-").replace(/\//g,"_").replace(/=/g,"")};#y=t=>{const e=t.replace(/-/g,"+").replace(/_/g,"/"),a=(4-e.length%4)%4,r=e.padEnd(e.length+a,"="),s=atob(r),i=new ArrayBuffer(s.length),n=new Uint8Array(i);for(let t=0;t<s.length;t++)n[t]=s.charCodeAt(t);return i};#h=()=>void 0!==(null===window||void 0===window?void 0:window.PublicKeyCredential)&&"function"==typeof window.PublicKeyCredential;#l=t=>{const{id:e}=t;return{...t,id:this.#y(e)}};priv={};async startRegistration(t){var e=this;if(!e.#h())throw new Error("WebAuthn is not supported in this browser");let a={...t,challenge:e.#y(t.challenge),user:{...t.user,id:e.#n(t.user.id)},excludeCredentials:t.excludeCredentials.map(this.#l)};const r=await navigator.credentials.create({publicKey:a});if(!r)throw new Error("Registration was not completed");const{id:s,rawId:i,response:n,type:o}=r,c={id:s,rawId:e.#c(i),response:{attestationObject:e.#c(n.attestationObject),clientDataJSON:e.#c(n.clientDataJSON)},type:o,clientExtensionResults:r.getClientExtensionResults()};return"function"==typeof n.getTransports&&(c.transports=n.getTransports()),c}async startAuthentication(t){var e,a,r=this;if(!r.#h())throw new Error("WebAuthn is not supported in this browser");let s;0!==(null===(e=t.allowCredentials)||void 0===e?void 0:e.length)&&(s=null===(a=t.allowCredentials)||void 0===a?void 0:a.map((t=>this.#l(t))));const i={...t,challenge:r.#y(t.challenge),allowCredentials:s},n=await navigator.credentials.get({publicKey:i});if(!n)throw new Error("Authentication was not completed");const{id:o,rawId:c,response:y,type:h}=n;let l;return y.userHandle&&(l=r.#o(y.userHandle)),{id:o,rawId:r.#c(c),response:{authenticatorData:r.#c(y.authenticatorData),clientDataJSON:r.#c(y.clientDataJSON),signature:r.#c(y.signature),userHandle:l},type:h,clientExtensionResults:n.getClientExtensionResults()}}async platformAuthenticatorIsAvailable(){return!!browserSupportsWebauthn()&&PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable()}}async function n(t,e,r,s,i,n){const o=new a;let c={apiData:{associationKey:"WEBSOCKET-TEST-SCRIPT",publicUserId:"public-User-ID"},browserData:{...await o.HKDFEncrypt(e,s.browserPublicKey,btoa(JSON.stringify(t))),publicKey:r},errorMsg:"",errors:!1},y={mode:"cors",method:"POST",body:JSON.stringify({...c,__salt:s.__salt,__hash:s.__hash})};await fetch(`https://${n}.api.keyri.com/api/v1/session/${i}`,y).then((async t=>await t.json())),window.close()}async function o(t,e,r,s,o,c){const y=new a;let h=btoa(JSON.stringify({timestamp:(new Date).getTime(),publicKey:e.signingKeys.publicKey})),l=await y.EcSignData(e.signingKeys.privateKey,h),p={challenge:btoa(JSON.stringify({data:h,signature:l,publicKey:e.signingKeys.publicKey})),rpId:document.location.host,userVerification:"discouraged",attestation:!1,timeout:6e4,requireResidentKey:!0};window.focus();const w=new i,u=await w.startAuthentication(p);let d=await fetch("https://c4xfkg8ea4.execute-api.us-east-2.amazonaws.com/prod/v1/browser/verify/",{method:"POST",mode:"cors",headers:{"Content-Type":"application/json"},body:JSON.stringify(u)}).then((async t=>await t.json()));if(!1!==c)return d;d.validationFormat="keyri-appless",await n(d,e.encryptionKeys.privateKey,e.encryptionKeys.publicKey,s,r,o)}class c{#r;#p;#w;#u;#d;#b;#m=!1;#t;#g;#K={signingKeys:{},encryptionKeys:{}};constructor(t){this.#p=t,this.#r=new s,this.#t=new a,this.#b=new EventTarget}on=(t,e)=>{this.#b.addEventListener(t,e)};#A=(t,e)=>{this.#b.dispatchEvent(new CustomEvent(t,{detail:e}))};register=async(t=!1)=>await this.#f({registration:t});authenticate=async()=>{try{return await o(0,this.#K,void 0,void 0,this.#p,void 0)}catch(t){console.log({ERROR:t})}};set passwordHandler(t){this.#g=t}start=async(t=!1)=>{this.#m=t;const{signingKeys:e,encryptionKeys:r}=await async function(){let t,e,r=new s,i=new a;await r.start("mobile","credentials");try{t=await r.reads("credentials","signingKeys"),e=await r.reads("credentials","encryptionKeys")}catch(t){throw new Error(t)}if(void 0===t){t=await i.EcMakeSigKeys(!1),t.id="signingKeys",e=await i.EcMakeCryptKeys(!1),e.id="encryptionKeys";try{await r.creates("credentials",t),await r.creates("credentials",e)}catch(t){throw new Error(t)}}return{signingKeys:t,encryptionKeys:e}}();if(this.#K.signingKeys=e,this.#K.encryptionKeys=r,!this.#m){const{sessionData:t,sessionId:a,userParameters:r}=await async function(t,e){let a,r,s=Object.fromEntries(Array.from(new URL(document.location).searchParams)).sessionId;if(!s)throw new Error("No Session Id Provided");let i={mode:"cors",method:"GET",headers:new Headers({"x-mobile-id":t})},n=`https://${e}.api.keyri.com/api/v1/session/${s}`;if(a=await fetch(n,i),!1===a?.ok)throw a=await a.json(),new Error(a.message);return a=await a.json(),r=atob(a?.userParameters?.base64EncodedData),r=JSON.parse(r),{sessionData:a,userParameters:r,sessionId:s}}(e.publicKey,this.#p);return this.#w=a,this.#u=t,this.#d=r,{sessionData:t,sessionId:a,userParameters:r}}};finish=async()=>{if("true"==this.#d?.register)return await this.#f(this.#d);try{return await o(this.#d,this.#K,this.#w,this.#u,this.#p,this.#m)}catch(t){console.log({ERROR:t})}};#f=async t=>{let e,a=t.registration;e=this.#g?await this.#g():"";try{t.registration=await this.#t.PASSWORD_DECRYPT(e,a.data)}catch(t){throw console.log("DATA DECRYPTION FAILED. WOMP WOMP!",{e:t}),new Error("PASSWORD DECRYPTION FAILED.")}let r=JSON.parse(t.registration),s=JSON.parse(atob(r.data)),o=JSON.parse(atob(s.child.data)),c=JSON.parse(atob(o.child.data)),y={child:r,publicKey:this.#K.signingKeys.publicKey,timestamp:(new Date).getTime()};y=btoa(JSON.stringify(y));let h=await this.#t.EcSignData(this.#K.signingKeys.privateKey,y),l=JSON.stringify({data:y,signature:h});console.log({userParameters:t,mobileData:y,browserTwo:s,rpData:o,browserData:c}),t.registration=btoa(l);let p={challenge:t.registration,rp:{name:o.origin,id:o.origin},user:{id:o.userId,name:o.userDisplayName,displayName:o.userDisplayName},pubKeyCredParams:[{alg:-7,type:"public-key"},{alg:-257,type:"public-key"}],timeout:6e4,attestation:"none",excludeCredentials:[],authenticatorSelection:{requireResidentKey:!0,userVerification:"discouraged"}};return await async function(t,e,a,r,s,o){{const c=new i;window.focus();let y=t.userParameters,h=t?.authoptions,l=await c.startRegistration(h),p=await fetch("https://c4xfkg8ea4.execute-api.us-east-2.amazonaws.com/prod/v1/browser/register/",{method:"POST",mode:"cors",headers:{"Content-Type":"application/json"},body:JSON.stringify({authenticatorData:l,userParameters:y})}).then((async t=>await t.json()));if(o)return p;await n(p,e.encryptionKeys.privateKey,e.encryptionKeys.publicKey,a,r,s)}}({authoptions:p,userParameters:t},this.#K,this.#u,this.#w,this.#p,this.#m)}}class y{#E;#S;#T;#v;#C;constructor(t,e,a){this.#T=t,this.#v=e,this.#C=a,this.#E=new r,this.#S=new c}register=async t=>{if(!t)throw new Error("Second Argument (METADATA) Cannot Be Blank! RP Needs Some Way To Identify Who Is Making Request.");await this.#S.start(!0);const e=await this.#E.register(this.#T,t);return await this.#S.register(e)};authenticate=async()=>(await this.#S.start(!0),await this.#S.authenticate());registerMobile=(t,e)=>{let a=Object.fromEntries(Array.from(new URL(document.location).searchParams));return a.register=!0,a.RP_API_URL=this.#T,a.METADATA=t,e&&(a.PASSWORD=e),new URLSearchParams(a)};rp_validate_data=async t=>{let e={method:"POST",headers:{"content-type":"application/json"},body:JSON.stringify(t)},a=await fetch(this.#v,e).then((async t=>t.json()));return await this.#C(a)}}window.LocalAppless=e.default})();
//# sourceMappingURL=appless-local.min.js.map
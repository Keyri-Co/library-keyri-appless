/*! For license information please see appless-local.min.js.LICENSE.txt */
(()=>{"use strict";var e={d:(t,a)=>{for(var r in a)e.o(a,r)&&!e.o(t,r)&&Object.defineProperty(t,r,{enumerable:!0,get:a[r]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t)},t={};e.d(t,{default:()=>o});class a{#e;constructor(){if("undefined"==typeof window&&"undefined"==typeof self)this.#t();else try{this.#e=window?.crypto,this.#e.CryptoKey=window?.CryptoKey}catch(e){this.#e=self?.crypto,this.#e.CryptoKey=self?.CryptoKey}}#t=async()=>{this.#e=await Object.getPrototypeOf((async function(){})).constructor('\n      return await import( "crypto" ).then((m) => {return m.default.webcrypto});\n')()};#a=async e=>{await new Promise(((t,a)=>{setTimeout((()=>t(!0)),e)}))};base64ToArray(e){return Uint8Array.from(atob(e),(e=>e.charCodeAt(0)))}arrayToBase64(e){return btoa(String.fromCharCode(...e))}HMAC=async(e,t)=>{await this.#a(0);let a=new TextEncoder("utf-8"),r=a.encode(e),s=a.encode(t),i=await this.#e.subtle.importKey("raw",r,{name:"HMAC",hash:{name:"SHA-256"}},!1,["sign","verify"]),n=await this.#e.subtle.sign("HMAC",i,s),o=new Uint8Array(n);return Array.prototype.map.call(o,(e=>("00"+e.toString(16)).slice(-2))).join("")};HASH=async(e,t,a)=>{await this.#a(0);let r,s=await this.#e.subtle.digest(e,(new TextEncoder).encode(t)),i=new Uint8Array(s);if(a){r=new Uint8Array(a,0),Math.min(a,i.length);let e=Math.max(a,i.length);for(var n=0;n<e;n++)r[n%a]=r[n%a]^i[n%i.length]}else r=i;return this.arrayToBase64(new Uint8Array(r))};PASSWORD_ENCRYPT=async(e,t)=>{await this.#a(0);for(let t=0;t<1e4;t++)e=this.HASH("SHA-512",e);let a=btoa(e),r=await this.AESMakeKey(!0),s=await this.AESEncrypt(r,t,a);return btoa(JSON.stringify({ciphertext:s.ciphertext,aes:r}))};PASSWORD_DECRYPT=async(e,t)=>{await this.#a(0);for(let t=0;t<1e4;t++)e=this.HASH("SHA-512",e);let a=btoa(e),r=JSON.parse(atob(t)),s=await this.AESImportKey(r.aes,!1),i=r.ciphertext;return await this.AESDecrypt(s,a,i,!0)};AESMakeKey=async(e=!0)=>{await this.#a(0);let t=await this.#e.subtle.generateKey({name:"AES-GCM",length:256},e,["encrypt","decrypt"]);if(e){let e=await this.#e.subtle.exportKey("raw",t);return this.arrayToBase64(new Uint8Array(e))}return t};AESImportKey=async(e,t=!0)=>(await this.#a(0),e instanceof this.#e.CryptoKey?e:await this.#e.subtle.importKey("raw",this.base64ToArray(e).buffer,"AES-GCM",t,["encrypt","decrypt"]));async AESEncrypt(e,t,a=!1){await this.#a(0);let r,s=await this.AESImportKey(e);r=a?this.base64ToArray(a):this.#e.getRandomValues(new Uint8Array(16));let i=await this.#e.subtle.encrypt({name:"AES-GCM",iv:r},s,this.base64ToArray(t));return{ciphertext:this.arrayToBase64(new Uint8Array(i)),iv:this.arrayToBase64(r)}}async AESDecrypt(e,t,a,r=!1){await this.#a(0);let s,i=await this.AESImportKey(e),n=this.base64ToArray(t),o=this.base64ToArray(a);return s=await this.#e.subtle.decrypt({name:"AES-GCM",iv:n},i,o),r?(s=new Uint8Array(s),s=(new TextDecoder).decode(s),s):s}EcMakeCryptKeys=async(e=!0)=>{await this.#a(0);let t,a=await this.#e.subtle.generateKey({name:"ECDH",namedCurve:"P-256"},e,["deriveKey","deriveBits"]);return t=e?await Promise.all([this.#e.subtle.exportKey("spki",a.publicKey).then((e=>this.arrayToBase64(new Uint8Array(e)))),this.#e.subtle.exportKey("pkcs8",a.privateKey).then((e=>this.arrayToBase64(new Uint8Array(e)))),this.#e.subtle.exportKey("jwk",a.publicKey).then((e=>e)),this.#e.subtle.exportKey("jwk",a.privateKey).then((e=>e)),this.#e.subtle.exportKey("raw",a.publicKey).then((e=>this.arrayToBase64(new Uint8Array(e)))),this.#e.subtle.exportKey("raw",a.publicKey).then((e=>this.arrayToBase64(new Uint8Array(e).slice(1,1e3))))]):await Promise.all([this.#e.subtle.exportKey("spki",a.publicKey).then((e=>this.arrayToBase64(new Uint8Array(e)))),new Promise(((e,t)=>e(a.privateKey))),this.#e.subtle.exportKey("raw",a.publicKey).then((e=>this.arrayToBase64(new Uint8Array(e)))),this.#e.subtle.exportKey("raw",a.publicKey).then((e=>this.arrayToBase64(new Uint8Array(e).slice(1,1e3))))]),e?{publicKey:t[0],privateKey:t[1],jwkPublicKey:t[2],jwkPrivateKey:t[3],rawPublicKey:t[4],rawPublicKeyLite:t[5]}:{publicKey:t[0],privateKey:t[1],rawPublicKey:t[2],rawPublicKeyLite:t[3]}};EcEncrypt=async(e,t,a)=>{await this.#a(0);let r=await this.EcdhConvertKey(t),s=await this.EcdhConvertKey(e);return await this.#e.subtle.deriveKey({name:"ECDH",public:r},s,{name:"AES-GCM",length:256},!1,["encrypt","decrypt"]),await this.AESEncrypt(b64_aes_key,a)};EcDecrypt=async(e,t,a,r)=>{let s=await this.EcdhConvertKey(t),i=await this.EcdhConvertKey(e),n=this.base64ToArray(a),o=this.base64ToArray(r),c=await this.#e.subtle.deriveKey({name:"ECDH",public:s},i,{name:"AES-GCM",length:256},!1,["encrypt","decrypt"]);return await this.#e.subtle.decrypt({name:"AES-GCM",iv:n},c,o)};HKDFEncrypt=async(e,t,a)=>{await this.#a(0);let r=await this.EcdhConvertKey(t),s=await this.EcdhConvertKey(e),i=await this.#e.subtle.deriveBits({name:"ECDH",namedCurve:"P-256",public:r},s,256),n=await this.#e.subtle.importKey("raw",i,{name:"HKDF"},!1,["deriveKey","deriveBits"]),o=this.#e.getRandomValues(new Uint8Array(16)),c=await this.#e.subtle.deriveBits({name:"HKDF",hash:"SHA-256",salt:o,info:new Uint8Array([])},n,256),y=await this.#e.subtle.importKey("raw",c,"AES-GCM",!1,["encrypt","decrypt"]),h=this.#e.getRandomValues(new Uint8Array(16)),l=await this.#e.subtle.encrypt({name:"AES-GCM",iv:h},y,this.base64ToArray(a));return{ciphertext:this.arrayToBase64(new Uint8Array(l)),salt:this.arrayToBase64(o),iv:this.arrayToBase64(h)}};HKDFDecrypt=async(e,t,a,r,s)=>{await this.#a(0);let i,n=await this.EcdhConvertKey(t),o=await this.EcdhConvertKey(e),c=this.base64ToArray(a),y=this.base64ToArray(r),h=this.base64ToArray(s),l=await this.#e.subtle.deriveBits({name:"ECDH",namedCurve:"P-256",public:n},o,256),p=await this.#e.subtle.importKey("raw",l,{name:"HKDF"},!1,["deriveKey","deriveBits"]),u=await this.#e.subtle.deriveBits({name:"HKDF",hash:"SHA-256",salt:c,info:new Uint8Array([])},p,256),w=await this.#e.subtle.importKey("raw",u,"AES-GCM",!1,["encrypt","decrypt"]);try{i=await this.#e.subtle.decrypt({name:"AES-GCM",iv:y},w,h)}catch(e){console.log({name:e.name,stack:e.stack,message:e.message})}return i};EcMakeSigKeys=async(e=!0)=>{await this.#a(0);let t,a=await this.#e.subtle.generateKey({name:"ECDSA",namedCurve:"P-256"},e,["sign","verify"]);return e?(t=await Promise.all([this.#e.subtle.exportKey("spki",a.publicKey).then((e=>this.arrayToBase64(new Uint8Array(e)))),this.#e.subtle.exportKey("pkcs8",a.privateKey).then((e=>this.arrayToBase64(new Uint8Array(e))))]),{publicKey:t[0],privateKey:t[1]}):(t=await Promise.all([this.#e.subtle.exportKey("spki",a.publicKey).then((e=>this.arrayToBase64(new Uint8Array(e))))]),{publicKey:t[0],privateKey:a.privateKey})};EcSignData=async(e,t)=>{await this.#a(0);let a=await this.EcdsaConvertKey(e),r=await this.#e.subtle.sign({name:"ECDSA",hash:{name:"SHA-256"}},a,this.base64ToArray(t));return await this.arrayToBase64(new Uint8Array(r))};EcVerifySig=async(e,t,a)=>{await this.#a(0);let r=await this.EcdsaConvertKey(e),s=this.base64ToArray(t);return await this.#e.subtle.verify({name:"ECDSA",hash:{name:"SHA-256"}},r,s,this.base64ToArray(a))};EcdhConvertKey=async e=>{let t,a;if(await this.#a(0),e instanceof this.#e.CryptoKey)return e;try{return t=await this.#e.subtle.importKey("spki",this.base64ToArray(e),{name:"ECDH",namedCurve:"P-256"},!0,[]),t}catch(e){}try{return t=await this.#e.subtle.importKey("raw",this.base64ToArray(e),{name:"ECDH",namedCurve:"P-256"},!0,[]),t}catch(e){}try{return t=await this.#e.subtle.importKey("pkcs8",this.base64ToArray(e),{name:"ECDH",namedCurve:"P-256"},!1,["deriveKey","deriveBits"]),t}catch(e){}try{return a=new Uint8Array([4].concat(Array.from(this.base64ToArray(e)))),t=await this.#e.subtle.importKey("raw",a,{name:"ECDH",namedCurve:"P-256"},!0,[]),t}catch(e){throw new Error("UNRECOGNIZED KEY FORMAT")}};EcdsaConvertKey=async e=>{let t,a;if(await this.#a(0),e instanceof this.#e.CryptoKey)return e;try{return t=await this.#e.subtle.importKey("spki",this.base64ToArray(e),{name:"ECDSA",namedCurve:"P-256"},!0,["verify"]),t}catch(e){}try{return t=await this.#e.subtle.importKey("raw",this.base64ToArray(e),{name:"ECDSA",namedCurve:"P-256"},!0,["verify"]),t}catch(e){}try{return t=await this.#e.subtle.importKey("pkcs8",this.base64ToArray(e),{name:"ECDSA",namedCurve:"P-256"},!1,["sign"]),t}catch(e){}try{return a=new Uint8Array([4].concat(Array.from(this.base64ToArray(e)))),t=await this.#e.subtle.importKey("raw",a,{name:"ECDSA",namedCurve:"P-256"},!0,["sign"]),t}catch(e){throw new Error("UNRECOGNIZED KEY FORMAT")}}}class r{register=async(e,t,r)=>{r||(r="");const s=new a,i=await s.EcMakeSigKeys(!1);let n=await(async(e,t)=>{const r=new a;let s=(new Date).getTime().toString(),i=e.publicKey,n=btoa(JSON.stringify({timestamp:s,publicKey:i,metadata:t})),o=await r.EcSignData(e.privateKey,n);return JSON.stringify({data:n,signature:o})})(i,t),o={method:"POST",headers:{"content-type":"application/json"},body:n},c=await fetch(e,o).then((async e=>e.json())),y=await(async(e,t)=>{const r=new a;let s=(new Date).getTime().toString(),i=e.publicKey,n=btoa(JSON.stringify({timestamp:s,publicKey:i,child:t}));return{data:n,signature:await r.EcSignData(e.privateKey,n)}})(i,c);return y=btoa(JSON.stringify(y)),y=await s.PASSWORD_ENCRYPT(r,y),console.log({encrypted:!0,data:y}),{encrypted:!0,data:y}}}class s{#r=e=>(new TextEncoder).encode(e);#s=e=>new TextDecoder("utf-8").decode(e);#i=e=>{const t=new Uint8Array(e);let a="";for(const e of t)a+=String.fromCharCode(e);return btoa(a).replace(/\+/g,"-").replace(/\//g,"_").replace(/=/g,"")};#n=e=>{const t=e.replace(/-/g,"+").replace(/_/g,"/"),a=(4-t.length%4)%4,r=t.padEnd(t.length+a,"="),s=atob(r),i=new ArrayBuffer(s.length),n=new Uint8Array(i);for(let e=0;e<s.length;e++)n[e]=s.charCodeAt(e);return i};#o=()=>void 0!==(null===window||void 0===window?void 0:window.PublicKeyCredential)&&"function"==typeof window.PublicKeyCredential;#c=e=>{const{id:t}=e;return{...e,id:this.#n(t)}};priv={};async startRegistration(e){var t=this;if(!t.#o())throw new Error("WebAuthn is not supported in this browser");let a={...e,challenge:t.#n(e.challenge),user:{...e.user,id:t.#r(e.user.id)},excludeCredentials:e.excludeCredentials.map(this.#c)};const r=await navigator.credentials.create({publicKey:a});if(!r)throw new Error("Registration was not completed");const{id:s,rawId:i,response:n,type:o}=r,c={id:s,rawId:t.#i(i),response:{attestationObject:t.#i(n.attestationObject),clientDataJSON:t.#i(n.clientDataJSON)},type:o,clientExtensionResults:r.getClientExtensionResults()};return"function"==typeof n.getTransports&&(c.transports=n.getTransports()),c}async startAuthentication(e){var t,a,r=this;if(!r.#o())throw new Error("WebAuthn is not supported in this browser");let s;0!==(null===(t=e.allowCredentials)||void 0===t?void 0:t.length)&&(s=null===(a=e.allowCredentials)||void 0===a?void 0:a.map((e=>this.#c(e))));const i={...e,challenge:r.#n(e.challenge),allowCredentials:s},n=await navigator.credentials.get({publicKey:i});if(!n)throw new Error("Authentication was not completed");const{id:o,rawId:c,response:y,type:h}=n;let l;return y.userHandle&&(l=r.#s(y.userHandle)),{id:o,rawId:r.#i(c),response:{authenticatorData:r.#i(y.authenticatorData),clientDataJSON:r.#i(y.clientDataJSON),signature:r.#i(y.signature),userHandle:l},type:h,clientExtensionResults:n.getClientExtensionResults()}}async platformAuthenticatorIsAvailable(){return!!browserSupportsWebauthn()&&PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable()}}class i{#y;#h;start=async(e,t,a)=>new Promise(((r,s)=>{try{const i=indexedDB.open(e,1);i.onerror=e=>{s(e)},i.onupgradeneeded=async e=>{this.#y=e.target.result;const r=this.#y.createObjectStore(t,{keyPath:"id"});a&&await Promise.all(a.map((e=>r.createIndex(e,e))))},i.onsuccess=e=>{this.#y=e.target.result,r(!0)}}catch(e){s(e)}}));#l=async e=>(await this.#y.transaction(e,"readwrite")).objectStore(e);creates=async(e,t)=>{const a=await this.#l(e);let r;try{return r=await a.add(t),await new Promise(((e,t)=>{r.onsuccess=()=>e(!0),r.onerror=e=>{throw new Error(e)}})),r.result}catch(e){return e}};reads=async(e,t)=>{const a=await this.#l(e);let r;try{return r=await a.get(t),await new Promise(((e,t)=>{r.onsuccess=()=>e(!0),r.onerror=e=>{throw new Error(e)}})),r.result}catch(e){return e}};updates=async(e,t)=>{if(!await this.reads(e,t.id))throw new Error("A record must exist before you can update it");const a=await this.#l(e);let r;try{return r=await a.put(t),await new Promise(((e,t)=>{r.onsuccess=()=>e(!0),r.onerror=e=>{throw new Error(e)}})),r.result}catch(e){return e}};deletes=async(e,t)=>{const a=await this.#l(e);let r;try{return r=await a.delete(t),await new Promise(((e,t)=>{r.onsuccess=()=>e(!0),r.onerror=e=>{throw new Error(e)}})),r.result}catch(e){return e}};searches=async(e,t,a)=>{const r=await this.#l(e);let s;try{let e=r.index(t);return s=await e.getAll(a),await new Promise(((e,t)=>{s.onsuccess=()=>e(!0),s.onerror=e=>{throw console.log({e}),new Error(e)}})),s.result}catch(e){return e}}}class n{#p;#u;#w;#d;#b=!1;#y;#e;#m={signingKeys:{},encryptionKeys:{}};#g;#K;constructor(e,t){this.#p=e,this.#u=t,this.#y=new i,this.#e=new a,this.#d=document.createDocumentFragment()}on=(e,t)=>{this.#d.addEventListener(e,t)};#A=(e,t)=>{this.#d.dispatchEvent(new CustomEvent(e,{detail:t}))};register=async(e=!1)=>await this.#E({registration:e});authenticate=async()=>await this.#f();set onPasswordRequest(e){console.log(e.toString()),this.#K=e}start=async(e=!1)=>{this.#b=e;const{signingKeys:t,encryptionKeys:r}=await async function(){let e,t,r=new i,s=new a;await r.start("mobile","credentials");try{e=await r.reads("credentials","signingKeys"),t=await r.reads("credentials","encryptionKeys")}catch(e){throw new Error(e)}if(void 0===e){e=await s.EcMakeSigKeys(!1),e.id="signingKeys",t=await s.EcMakeCryptKeys(!1),t.id="encryptionKeys";try{await r.creates("credentials",e),await r.creates("credentials",t)}catch(e){throw new Error(e)}}return console.log({signingKeys:e,encryptionKeys:t}),{signingKeys:e,encryptionKeys:t}}();if(this.#m.signingKeys=t,this.#m.encryptionKeys=r,!this.#b){const{sessionId:e,userParameters:a}=await async function(e,t,a){let r=Object.fromEntries(Array.from(new URL(document.location).searchParams)).sessionId,s={mode:"cors",method:"GET",headers:new Headers({"x-mobile-id":e})},i=await fetch(`https://${t}.api.keyri.com/api/v1/session/${r}?appKey=${a}`,s).then((async e=>await e.json())),n=atob(i?.userParameters?.base64EncodedData);return n=JSON.parse(n),console.log("MODULE",{sessionData:i,userParameters:n}),{userParameters:n,sessionId:r}}(t.publicKey,this.#p,this.#u);console.log("OUTSIDE",{sessionId:e,userParameters:a})}};#S=async()=>{let e=Object.fromEntries(Array.from(new URL(document.location).searchParams));this.#w=e.sessionId;let t={mode:"cors",method:"GET",headers:new Headers({"x-mobile-id":this.#m.signingKeys.publicKey})};this.#g=await fetch(`https://${this.#p}.api.keyri.com/api/v1/session/${this.#w}?appKey=${this.#u}`,t).then((async e=>await e.json())),console.log(this.#g);let a=atob(this.#g?.userParameters?.base64EncodedData);return a=JSON.parse(a),"true"==a?.register?await this.#E(a):await this.#f(a)};#E=async e=>{let t,a=e.registration;t=this.#K?await this.#K():"";try{e.registration=await this.#e.PASSWORD_DECRYPT(t,a.data)}catch(e){throw console.log("DATA DECRYPTION FAILED. WOMP WOMP!",{e}),new Error("PASSWORD DECRYPTION FAILED.")}let r=JSON.parse(e.registration),s=JSON.parse(atob(r.data)),i=JSON.parse(atob(s.child.data)),n=JSON.parse(atob(i.child.data)),o={child:r,publicKey:this.#m.signingKeys.publicKey,timestamp:(new Date).getTime()};o=btoa(JSON.stringify(o));let c=await this.#e.EcSignData(this.#m.signingKeys.privateKey,o),y=JSON.stringify({data:o,signature:c});console.log({userParameters:e,mobileData:o,browserTwo:s,rpData:i,browserData:n}),e.registration=btoa(y);let h={challenge:e.registration,rp:{name:i.origin,id:i.origin},user:{id:i.userId,name:i.userDisplayName,displayName:i.userDisplayName},pubKeyCredParams:[{alg:-7,type:"public-key"},{alg:-257,type:"public-key"}],timeout:6e4,attestation:"none",excludeCredentials:[],authenticatorSelection:{requireResidentKey:!0,userVerification:"discouraged"}};return await this.#T({authoptions:h,userParameters:e})};#T=async e=>{const t=new s;window.focus();let a=e.userParameters,r=e?.authoptions,i=await t.startRegistration(r);console.log({passKey:i});let n=await fetch("https://c4xfkg8ea4.execute-api.us-east-2.amazonaws.com/prod/v1/browser/register/",{method:"POST",mode:"cors",headers:{"Content-Type":"application/json"},body:JSON.stringify({authenticatorData:i,userParameters:a})}).then((async e=>await e.json()));if(this.#b)return n;await this.#C(n)};#f=async e=>{let t=btoa(JSON.stringify({timestamp:(new Date).getTime(),publicKey:this.#m.signingKeys.publicKey})),a=await this.#e.EcSignData(this.#m.signingKeys.privateKey,t),r={challenge:btoa(JSON.stringify({data:t,signature:a,publicKey:this.#m.signingKeys.publicKey})),rpId:document.location.origin.replace(/^.*?\/\//,""),userVerification:"discouraged",timeout:6e4,requireResidentKey:!0};window.focus();const i=new s,n=await i.startAuthentication(r);let o=await fetch("https://c4xfkg8ea4.execute-api.us-east-2.amazonaws.com/prod/v1/browser/verify/",{method:"POST",mode:"cors",headers:{"Content-Type":"application/json"},body:JSON.stringify(n)}).then((async e=>await e.json()));if(this.#b)return o;o.validationFormat="keyri-appless",await this.#C(o)};#C=async e=>{let t={apiData:{associationKey:"WEBSOCKET-TEST-SCRIPT",publicUserId:"public-User-ID"},browserData:{...await this.#e.HKDFEncrypt(this.#m.encryptionKeys.privateKey,this.#g.browserPublicKey,btoa(JSON.stringify(e))),publicKey:this.#m.encryptionKeys.publicKey},errorMsg:"",errors:!1},a={mode:"cors",method:"POST",body:JSON.stringify({...t,__salt:this.#g.__salt,__hash:this.#g.__hash})};await fetch(`https://${this.#p}.api.keyri.com/api/v1/session/${this.#w}`,a).then((async e=>await e.json())),window.close()}}class o{#v;#P;#D;#R;#U;constructor(e,t,a){this.#D=e,this.#R=t,this.#U=a,this.#v=new r,this.#P=new n}register=async e=>{if(!e)throw new Error("Second Argument (METADATA) Cannot Be Blank! RP Needs Some Way To Identify Who Is Making Request.");await this.#P.start(!0);const t=await this.#v.register(this.#D,e);return await this.#P.register(t)};authenticate=async()=>(await this.#P.start(!0),await this.#P.authenticate());registerMobile=(e,t)=>{let a=Object.fromEntries(Array.from(new URL(document.location).searchParams));return a.register=!0,a.RP_API_URL=this.#D,a.METADATA=e,t&&(a.PASSWORD=t),new URLSearchParams(a)};rp_validate_data=async e=>{let t={method:"POST",headers:{"content-type":"application/json"},body:JSON.stringify(e)},a=await fetch(this.#R,t).then((async e=>e.json()));return await this.#U(a)}}window.LocalAppless=t.default})();
//# sourceMappingURL=appless-local.min.js.map
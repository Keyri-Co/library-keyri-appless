(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["Appless"] = factory();
	else
		root["Appless"] = factory();
})(this, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	// The require scope
/******/ 	var __webpack_require__ = {};
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
/*!***********************************!*\
  !*** ./src/index.js + 12 modules ***!
  \***********************************/
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "ApplessBrowser": () => (/* reexport */ ApplessBrowser),
  "ApplessLocal": () => (/* reexport */ ApplessLocal),
  "ApplessMobile": () => (/* reexport */ ApplessMobile)
});

;// CONCATENATED MODULE: ./node_modules/@justinwwolcott/ez-web-crypto/index.js
// ////////////////////////////////////////////////////////////////////////////
// ////////////////////////////////////////////////////////////////////////////
// ////////////////////////////////////////////////////////////////////////////
//
// Class with methods to make working with subtle crypto
// easier and more obvious
//

class EZCrypto {
  
  #crypto;
  
  constructor() {
    if(typeof window == "undefined" && typeof self == "undefined"){
      this.#nodeEnvLoad();
    } else {
      try{
        this.#crypto = window?.crypto;
        this.#crypto.CryptoKey = window?.CryptoKey;
      } catch(e){
        this.#crypto = self?.crypto;
        this.#crypto.CryptoKey = self?.CryptoKey;
      }
    } 
  }

  // //////////////////////////////////////////////////////////////////////////
  // //////////////////////////////////////////////////////////////////////////
  #nodeEnvLoad = async () => {
    this.#crypto =  await Object.getPrototypeOf(async function(){}).constructor(
`
      return await import( "crypto" ).then((m) => {return m.default.webcrypto});
`
    )();  
  }

  // //////////////////////////////////////////////////////////////////////////
  // //////////////////////////////////////////////////////////////////////////
  #sleep = async (duration) => {
    await new Promise((s,j) => {setTimeout(() => {return s(true)},duration)});
  }

  // //////////////////////////////////////////////////////////////////////////
  // //////////////////////////////////////////////////////////////////////////
  //
  // Function:     base64ToArray
  // What is this: Take a base64 string. Convert it to a Uint8Array...
  //
  // Arguments:    strng: - base64 encoded string
  //
  // Returns:      Uint8Array
  // Notes:
  //
  // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
  // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

  base64ToArray(strng) {
    return Uint8Array.from(atob(strng), (c) => c.charCodeAt(0));
  }

  // //////////////////////////////////////////////////////////////////////////
  // //////////////////////////////////////////////////////////////////////////
  //
  // Function:     arrayToBase64
  // What is this: take a Uint8Array, make it a valid base64 string
  //
  // Arguments:    ary: - Uint8Array
  //
  // Returns:      Base64 String
  // Notes:
  //
  // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
  // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

  arrayToBase64(ary) {
    return btoa(String.fromCharCode(...ary));
  }

  // //////////////////////////////////////////////////////////////////////////
  // //////////////////////////////////////////////////////////////////////////
  //
  // Function:     hmac (static) (async)
  // What is this: Create a cryptographic signature for a piece of data given a *SHARED* secret.
  //               Similar to ECDSA - Except both parties have to have the secret-key in advance
  //               to make it work.
  //
  // Arguments:    secret - this is the shared secret
  //               data   - this is the string you're encrypting
  //
  // Returns:      hex encoded 32 character string or something...(todo: check length - better def)
  // Notes:        https://stackoverflow.com/questions/47329132/how-to-get-hmac-with-crypto-web-api#47332317
  //
  // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
  // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

  HMAC = async (secret, data) => {
    await this.#sleep(0);

    // To do work, we need to convert text to Uint8Arrays
    let encoder = new TextEncoder("utf-8");
    let encodedSecret = encoder.encode(secret);
    let encodedData = encoder.encode(data);

    // Create our HMAC Key
    let key = await this.#crypto.subtle.importKey(
      "raw",
      encodedSecret,
      { name: "HMAC", hash: { name: "SHA-256" } },
      false,
      ["sign", "verify"]
    );

    // HMAC Sign our data with our HMAC Key
    let sig = await this.#crypto.subtle.sign("HMAC", key, encodedData);

    // Turn the signature into an array; then into hex-text
    // (todo: Maybe this is its own method...?)
    //
    let b = new Uint8Array(sig);
    let str = Array.prototype.map
      .call(b, (x) => ("00" + x.toString(16)).slice(-2))
      .join("");

    return str;
  }


  // //////////////////////////////////////////////////////////////////////////
  // //////////////////////////////////////////////////////////////////////////
  //
  // Function:     HASH (static) (async)
  // What is this: The digest() method of the SubtleCrypto interface generates a digest of the given data. 
  //               A digest is a short fixed-length value derived from some variable-length input.
  //               Cryptographic digests should exhibit collision-resistance, meaning that it's hard to come up 
  //               with two different inputs that have the same digest value.
  //
  // Arguments:    algo - this is the string you're hashing for
  //               data   - This is the algorithm you're using to hash the data with (SHA-1, SHA-256, SHA-384, SHA-512)
  //
  // Returns:      the hash of the data you provided as a base64 string
  //
  // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
  // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
  HASH = async (algo, data, len) => {

    await this.#sleep(0);

    let hash = await this.#crypto.subtle.digest(algo, new TextEncoder().encode(data));
    
    let ary = new Uint8Array(hash);

    let outAry;

    if(len){
      // initialize outAry to the desired size
      outAry = new Uint8Array(len,0);

      let min = Math.min(len, ary.length);
      let max = Math.max(len, ary.length);

      for(var i = 0; i < max; i++){
        outAry[i%len] = outAry[i%len] ^ ary[i%ary.length];
      }
    } else {
      outAry = ary;
    }

    return this.arrayToBase64(new Uint8Array(outAry));

  }



  // //////////////////////////////////////////////////////////////////////////
  // //////////////////////////////////////////////////////////////////////////
  //
  //
  // Function:     PASSWORD_ENCRYPT
  // What is this: Dead simple method to encrypt a piece of data with a password
  //               that can later be decrypted needing only that password 
  //
  // Arguments:    password: string; plaintext string of user's password
  //               base64data: string; what you want to encrypt
  //
  // Returns:      base64 encoded, stringified object containing the AES key used
  //               to encrypt the data, and the ciphertext itself
  // Notes:
  //
  //
  // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
  // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
  PASSWORD_ENCRYPT = async(password, base64data) => {

      await this.#sleep(0);

      // let passwordHash = this.HASH("SHA-512", password);

      for(let i = 0; i < 10_000; i++){
        password = this.HASH("SHA-512", password);
      }
      
      let passwordHash = btoa(password);
    
      let aes = await this.AESMakeKey(true);

      let output = await this.AESEncrypt(aes, base64data, passwordHash);

      return btoa(JSON.stringify({ciphertext: output.ciphertext, aes}));
  }



  // //////////////////////////////////////////////////////////////////////////
  // //////////////////////////////////////////////////////////////////////////
  //
  //
  // Function:     PASSWORD_DECRYPT
  // What is this: Counterparty to PASSWORD_ENCRYPT. Give it a password, and
  //               the encrypted data from PASSWORD_ENCRYPT; it should give you
  //               the initial plaintext...
  //
  // Arguments:    password: string; plaintext string of user's password
  //               base64data: password-data
  //
  // Returns:      plaintext
  //
  // Notes:
  //
  //
  // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
  // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
  PASSWORD_DECRYPT = async(password, base64data) => {

    await this.#sleep(0);

      // let passwordHash = this.HASH("SHA-512", password);

      for(let i = 0; i < 10_000; i++){
        password = this.HASH("SHA-512", password);
      }
      
      let passwordHash = btoa(password);

    let encryptedDataObject = JSON.parse(atob(base64data));
  
    let aes = await this.AESImportKey(encryptedDataObject.aes,false);

    let ciphertext = encryptedDataObject.ciphertext;

    let plaintext = await this.AESDecrypt(aes, passwordHash, ciphertext, true);

    return plaintext;
}








  // //////////////////////////////////////////////////////////////////////////
  // //////////////////////////////////////////////////////////////////////////
  //
  // Function:     AESMakeKey (async)
  // What is this: Generate an AES Key and return its hex
  //
  // Arguments:    *NONE*
  //
  // Returns:      base64 string
  // Notes:
  //
  // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
  // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

  AESMakeKey = async (exportable = true) => {
    await this.#sleep(0);

    // 1.) Generate the Key
    let key = await this.#crypto.subtle.generateKey(
      { name: "AES-GCM", length: 256 },
      exportable,
      ["encrypt", "decrypt"]
    );


    // 2.) 
    if(exportable){
      //Return it as b64 if its exportable
      
      let out = await this.#crypto.subtle.exportKey("raw", key);
      return this.arrayToBase64(new Uint8Array(out));
    } else {
      // else return the CryptoKey Object
      
      return key;
    }
  };
  
  
  // //////////////////////////////////////////////////////////////////////////
  // //////////////////////////////////////////////////////////////////////////
  //
  // Function:     AESImportKey (async)
  // What is this: Generate an AES Key and return its hex
  //
  // Arguments:    base64 string
  //
  // Returns:      Live AES Key
  // Notes:
  //
  // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
  // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

  AESImportKey = async (aes_key, exportable = true) => {
    await this.#sleep(0);


    if(aes_key instanceof this.#crypto.CryptoKey){
      return aes_key;
    } else {

      // 1.) Generate the Key
      return await this.#crypto.subtle.importKey(
          "raw",
          this.base64ToArray(aes_key).buffer,
          "AES-GCM",
          exportable,
          ["encrypt", "decrypt"]
        );
    }
  };

  // //////////////////////////////////////////////////////////////////////////
  // //////////////////////////////////////////////////////////////////////////
  //
  // Function:     AESEncrypt (async)
  // What is this: Given
  //
  // Arguments:    key:  base64 AES-key
  //               data: uInt8Array
  //
  // Returns:      base64 string
  // Notes:
  //
  // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
  // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

  async AESEncrypt(base_64_key, base_64_data, base_64_nonce = false) {
    await this.#sleep(0);
    
    // 0.) Pass Key to 
    let aes_key = await this.AESImportKey(base_64_key);


    // 3.) Create a nonce why not?
    let nonce;
    
    if(base_64_nonce){
      nonce = this.base64ToArray(base_64_nonce);
    } else {
      nonce = this.#crypto.getRandomValues(new Uint8Array(16));
    }

    // 4.) encrypt our data
    let encrypted = await this.#crypto.subtle.encrypt(
      { name: "AES-GCM", iv: nonce },
      aes_key,
      this.base64ToArray(base_64_data)
    );

    // 5.) Base64 and return our data...
    return {
      ciphertext: this.arrayToBase64(new Uint8Array(encrypted)),
      iv: this.arrayToBase64(nonce),
    };
  }

  // //////////////////////////////////////////////////////////////////////////
  // //////////////////////////////////////////////////////////////////////////
  //
  // Function:     AESDecrypt (async)
  // What is this: Given
  //
  // Arguments:    key:  base64 AES-key
  //               nonce: base64 of the nonce used at encryption (ok if it is public)
  //               ciphertext: base64 of what's been encoded
  //
  // Returns:      base64 string
  // Notes:
  //
  // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
  // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

  async AESDecrypt(base_64_key, base_64_nonce, base_64_cipher, returnText = false) {
    await this.#sleep(0);

    // 1.) Convert out from base64 to array
    let aes_key = await this.AESImportKey(base_64_key);
    let nonce_ary = this.base64ToArray(base_64_nonce);
    let cipher_ary = this.base64ToArray(base_64_cipher);
    let decrypted;



    // 3.) Decrypt
    decrypted = await this.#crypto.subtle.decrypt(
      { name: "AES-GCM", iv: nonce_ary },
      aes_key,
      cipher_ary
    );

    if(!returnText){
      return decrypted;
    } else {
      decrypted = new Uint8Array(decrypted);

      decrypted = new TextDecoder().decode(decrypted);

      return decrypted;
    }
  }

  // //////////////////////////////////////////////////////////////////////////
  // //////////////////////////////////////////////////////////////////////////
  //
  // Function:     EcMakeCryptKeys (async)
  // What is this: Given
  //
  // Arguments:    none
  //
  // Returns:      object containing public and private key pair
  // Notes:
  //
  // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
  // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

  EcMakeCryptKeys = async (exportable = true) => {
    await this.#sleep(0);

    // Step 1) Create ECDH KeyS
    let keys = await this.#crypto.subtle.generateKey(
      { name: "ECDH", namedCurve: "P-256" },
      exportable,
      ["deriveKey","deriveBits"]
    );

    // Step 2) Export keys to SPKI|PKCS8|JWK|RAW format
    let exportKeys;

    if(exportable){
      exportKeys = await Promise.all([
          this.#crypto.subtle.exportKey("spki", keys.publicKey).then((key) => {
            return this.arrayToBase64(new Uint8Array(key));
          }),
          this.#crypto.subtle.exportKey("pkcs8", keys.privateKey).then((key) => {
            return this.arrayToBase64(new Uint8Array(key));
          }),
          this.#crypto.subtle.exportKey("jwk", keys.publicKey).then((key) => {
            return (key);
          }),
          this.#crypto.subtle.exportKey("jwk", keys.privateKey).then((key) => {
            return (key);
          }),
          this.#crypto.subtle.exportKey("raw", keys.publicKey).then((key) => {
            return this.arrayToBase64( new Uint8Array(key));
          }),
          this.#crypto.subtle.exportKey("raw", keys.publicKey).then((key) => {
            return this.arrayToBase64( new Uint8Array(key).slice(1,1000));
          })
      ]);
      
    } else {
      exportKeys = await Promise.all([
        //
          this.#crypto.subtle.exportKey("spki", keys.publicKey).then((key) => {
            return this.arrayToBase64(new Uint8Array(key));
          }),
        //
        (new Promise((s,j) => {return s(keys.privateKey)})),
        //
          this.#crypto.subtle.exportKey("raw", keys.publicKey).then((key) => {
            return this.arrayToBase64( new Uint8Array(key));
          }),
        //
          this.#crypto.subtle.exportKey("raw", keys.publicKey).then((key) => {
            return this.arrayToBase64( new Uint8Array(key).slice(1,1000));
          })
      ]);
    }

    if(exportable){
      return { 
        publicKey: exportKeys[0], 
        privateKey: exportKeys[1], 
        jwkPublicKey: exportKeys[2], 
        jwkPrivateKey: exportKeys[3], 
        rawPublicKey: exportKeys[4],
        rawPublicKeyLite: exportKeys[5]
      };
    } else {
        return { 
          publicKey: exportKeys[0], 
          privateKey: exportKeys[1], 
          rawPublicKey: exportKeys[2], 
          rawPublicKeyLite: exportKeys[3]
        };
    }

    // Step 3) Convert the keys to base64 and return...
  };

  // //////////////////////////////////////////////////////////////////////////
  // //////////////////////////////////////////////////////////////////////////
  //
  // Function:     EcEncrypt (async)
  // What is this: Encrypt Uint8Data with 2 SPKI-Encoded ECDH Keys.
  //               ---
  //               Basically it does the dirty work of:
  //               - convert base64 keys to live keys
  //               - creating AES key from live keys
  //               - encrypting data with AES Key
  //               - return base64 ciphertext and nonce
  //
  //
  // Arguments:    base64privateKey: string;
  //               base64publicKey: string;
  //               base64data: string;
  //
  // Returns:      object containing public and private key pair
  // Notes:
  //
  // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
  // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

  EcEncrypt = async (b64Private, b64Public, b64data) => {
    await this.#sleep(0);

    // 1.) convert the given keys to real keys in the most
    //     generic way possible...
    let publicKey = await this.EcdhConvertKey(b64Public);
    let privateKey = await this.EcdhConvertKey(b64Private);
    
    // 2.) generate shared key
    let aes_key = await this.#crypto.subtle.deriveKey(
      { name: "ECDH", public: publicKey },
      privateKey,
      { name: "AES-GCM", length: 256 },
      false,
      ["encrypt", "decrypt"]
    )
    
    // 3.) Work smarter, not harder, dummy...
    return await this.AESEncrypt(b64_aes_key, b64data);
  
  };

  // //////////////////////////////////////////////////////////////////////////
  // //////////////////////////////////////////////////////////////////////////
  //
  // Function:     EcDecrypt (async)
  // What is this: Decrypt Uint8Data with 2 SPKI-Encoded ECDH Keys.
  //               ---
  //               Basically it does the dirty work of:
  //               - convert base64 keys to live keys
  //               - creating AES key from live keys
  //               - encrypting data with AES Key
  //               - return base64 ciphertext and nonce
  //
  //
  // Arguments:    base64privateKey: string;
  //               base64publicKey: string;
  //               base64nonce: string;
  //               base64data: string;
  //
  // Returns:      object containing public and private key pair
  // Notes:
  //
  // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
  // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

  EcDecrypt = async (b64Private, b64Public, b64Nonce, b64data) => {

    // 1.) convert the given keys to real keys in the most
    //     generic way possible...
    let publicKey = await this.EcdhConvertKey(b64Public);
    let privateKey = await this.EcdhConvertKey(b64Private);
    let nonce = this.base64ToArray(b64Nonce);
    let data = this.base64ToArray(b64data);

    // 2.) generate shared key
    let aes_key = await this.#crypto.subtle.deriveKey(
      { name: "ECDH", public: publicKey },
      privateKey,
      { name: "AES-GCM", length: 256 },
      false,
      ["encrypt", "decrypt"]
    );

    // 4.) encrypt our data
    return await this.#crypto.subtle.decrypt(
      { name: "AES-GCM", iv: nonce },
      aes_key,
      data
    );
  };
  



















  // //////////////////////////////////////////////////////////////////////////
  // //////////////////////////////////////////////////////////////////////////
  //
  // Function:     HKDFEncrypt (async)
  // What is this: Encrypt Uint8Data with 2 SPKI-Encoded ECDH Keys.
  //               ---
  //               Basically it does the dirty work of:
  //               - convert base64 keys to live keys
  //               - creating AES key from live keys
  //               - encrypting data with AES Key
  //               - return base64 ciphertext and nonce
  //
  //
  // Arguments:    base64privateKey: string;
  //               base64publicKey: string;
  //               base64data: string;
  //
  // Returns:      object containing public and private key pair
  // Notes:
  //
  // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
  // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

  HKDFEncrypt = async (b64Private, b64Public, b64data) => {
    await this.#sleep(0);

    // 1.) convert the given keys to real keys in the most
    //     generic way possible...
    let publicKey = await this.EcdhConvertKey(b64Public);
    let privateKey = await this.EcdhConvertKey(b64Private);
    
    // 2.) generate shared secret for HKDF
    //
    let sharedSecret = await this.#crypto.subtle.deriveBits({ 
      "name": "ECDH", 
      "namedCurve": "P-256", 
      "public": publicKey 
    },privateKey,256);
    
    // 3.) convert shared-secret into a key
    //
    let sharedSecretKey = await this.#crypto.subtle.importKey(
      "raw", sharedSecret, 
      { "name": 'HKDF' }, 
      false, 
      ['deriveKey','deriveBits']
    );
    
    // 4.) create SALT
    //
    let salt = this.#crypto.getRandomValues(new Uint8Array(16));
    
    // 5.) convert the live-shared-secret-key into an aes key
    //
    let derivedKey = await this.#crypto.subtle.deriveBits({
      "name": 'HKDF', 
      "hash": 'SHA-256', 
      "salt": salt,
      "info": new Uint8Array([])},
      sharedSecretKey,256
    );
    
    //
    // 6.) 
    // THIS SHOULD NOT BE THIS HARD!
    //
    //     Convert the Key-Array to a live Key
    let aes_key = await this.#crypto.subtle.importKey(
      "raw",
      derivedKey,
      "AES-GCM",
      false,
      ["encrypt","decrypt"]
    );
    
    // 7.) Init Vector
    //
    //
    let iv = this.#crypto.getRandomValues(new Uint8Array(16));
    
    // 7.) Encrypt
    //
    //
    let encrypted = await this.#crypto.subtle.encrypt(
      { name: "AES-GCM", iv: iv },
      aes_key,
      this.base64ToArray(b64data)
    );
    
    // 8.) Base64 and return our data...
    return {
      "ciphertext": this.arrayToBase64(new Uint8Array(encrypted)),
      "salt": this.arrayToBase64(salt),
      "iv": this.arrayToBase64(iv)
    };

  
  };

  // //////////////////////////////////////////////////////////////////////////
  // //////////////////////////////////////////////////////////////////////////
  //
  // Function:     HKDFDecrypt (async)
  // What is this: Decrypt Uint8Data with 2 SPKI-Encoded ECDH Keys.
  //               ---
  //               Basically it does the dirty work of:
  //               - convert base64 keys to live keys
  //               - creating AES key from live keys
  //               - encrypting data with AES Key
  //               - return base64 ciphertext and nonce
  //
  //
  // Arguments:    base64privateKey: string;
  //               base64publicKey: string;
  //               base64nonce: string;
  //               base64data: string;
  //
  // Returns:      object containing public and private key pair
  // Notes:
  //
  // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
  // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

  HKDFDecrypt = async (b64Private, b64Public, b64Salt, b64iv, b64data) => {
    await this.#sleep(0);

    // 1.) convert the given keys to real keys in the most
    //     generic way possible...
    let publicKey = await this.EcdhConvertKey(b64Public);
    
    let privateKey = await this.EcdhConvertKey(b64Private);
    
    let salt = this.base64ToArray(b64Salt);
    let iv = this.base64ToArray(b64iv);
    let data = this.base64ToArray(b64data);
    
    
    // 2.) generate shared secret for HKDF
    //
    let sharedSecret = await this.#crypto.subtle.deriveBits({ 
      "name": "ECDH", 
      "namedCurve": "P-256", 
      "public": publicKey 
    },privateKey,256);
    
    // 3.) convert shared-secret into a key
    //
    let sharedSecretKey = await this.#crypto.subtle.importKey(
      "raw", sharedSecret, 
      { "name": 'HKDF' }, 
      false, 
      ['deriveKey','deriveBits']
    );
    
    // 4.) convert the live-shared-secret-key into an aes key
    //
    let derivedKey = await this.#crypto.subtle.deriveBits({
      "name": 'HKDF', 
      "hash": 'SHA-256', 
      "salt": salt,
      "info": new Uint8Array([])},
      sharedSecretKey,256
    );

    //
    // 5.) 
    //     Convert the Key-Array to a live Key
    let aes_key = await this.#crypto.subtle.importKey(
      "raw",
      derivedKey,
      "AES-GCM",
      false,
      ["encrypt","decrypt"]
    );

    // 6.) decrypt our data
    //
    let aes_data;
    try{
        aes_data = await this.#crypto.subtle.decrypt(
        { name: "AES-GCM", iv: iv },
        aes_key,
        data
      );
    } catch(e){
      console.log({name: e.name, stack: e.stack, message: e.message});
    }

    return aes_data;

  };
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  // //////////////////////////////////////////////////////////////////////////
  // //////////////////////////////////////////////////////////////////////////
  //
  // Function:     EcMakeSigKeys (async)
  // What is this: Given
  //
  // Arguments:    none
  //
  // Returns:      object containing public and private key pair
  // Notes:
  //
  // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
  // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
  
  EcMakeSigKeys = async (exportable = true) => {
    await this.#sleep(0);

  // Step 1) Create ECDSA KeyS
    let keys = await this.#crypto.subtle.generateKey(
      { name: "ECDSA", namedCurve: "P-256" },
      exportable,
      ["sign","verify"]
    );
    
    let b64Keys;

  // Step 2a) IF EXTRACTABLE: Export keys to SPKI|PKCS8 format
    if(exportable){
      b64Keys = await Promise.all([
        this.#crypto.subtle.exportKey("spki", keys.publicKey).then((key) => {
          return this.arrayToBase64(new Uint8Array(key));
        }),
        this.#crypto.subtle.exportKey("pkcs8", keys.privateKey).then((key) => {
          return this.arrayToBase64(new Uint8Array(key));
        })
      ]);
      
      return { publicKey: b64Keys[0], privateKey: b64Keys[1] };

    } else {
      
  // Step 2b) NOT NOT NOT EXTRACTABLE: Export just the public key
      b64Keys = await Promise.all([
        this.#crypto.subtle.exportKey("spki", keys.publicKey).then((key) => {
          return this.arrayToBase64(new Uint8Array(key));
        })
      ]);
      return { publicKey: b64Keys[0], privateKey: keys.privateKey };
    }

  };
  
  
  
  // //////////////////////////////////////////////////////////////////////////
  // //////////////////////////////////////////////////////////////////////////
  //
  // Function:     EcSignData (async)
  // What is this: Create a crypto-signature from a private key and data
  //
  // Arguments:    base64privateKey: string;
  //               data: Uint8Array;
  //
  // Returns:      base64 encoded signature
  // Notes:
  //
  // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
  // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

  EcSignData = async (b64PrivateKey, b64data) => {
    await this.#sleep(0);

    // 1.) convert the given keys to real keys
    let privateKey = await this.EcdsaConvertKey(b64PrivateKey);

    // 2.) sign the data with the live key
    let signature = await this.#crypto.subtle.sign({"name": "ECDSA", "hash": {"name": "SHA-256"}}, privateKey, this.base64ToArray(b64data));

    // 3.) Base64 and return our data...
    return  await this.arrayToBase64(new Uint8Array(signature));
  
  };
  
  
  // //////////////////////////////////////////////////////////////////////////
  // //////////////////////////////////////////////////////////////////////////
  //
  // Function:     EcVerifySig (async)
  // What is this: Given a public key, some data, and a signature; prove the
  //               signature came from the data and the public key
  //
  // Arguments:    base64PublicKey: string;
  //               data: Uint8Array;
  //
  // Returns:      base64 encoded signature
  // Notes:
  //
  // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
  // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

  EcVerifySig = async (b64PublicKey, b64Signature, b64data) => {
    await this.#sleep(0);

    // 1.) convert the given keys to real keys
    let publicKey = await this.EcdsaConvertKey(b64PublicKey);
    

    // 2.) Convert the signature to an array
    let signature = this.base64ToArray(b64Signature);

    // 3.) verify the data with the live key
    return await this.#crypto.subtle.verify({"name": "ECDSA", "hash": {"name": "SHA-256"}}, publicKey, signature, this.base64ToArray(b64data));

  };
  
  
  
  
  
  
  
  // //////////////////////////////////////////////////////////////////////////
  // //////////////////////////////////////////////////////////////////////////
  //
  // Function:     EzConvertKey (base64key)
  // What is this: Sloppy AF function to try converting random data into a key
  //               until something works...
  //
  // Arguments:    none
  //
  // Returns:      hopefully a live key...probably an error and an hour of debugging.
  // Notes:
  //
  // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
  // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
  
  
  
  EcdhConvertKey = async (unknown_key) => {
    await this.#sleep(0);

    let key;
    let longKey;
    
    // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
    // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
    // NATURAL KEY
    if(unknown_key instanceof this.#crypto.CryptoKey){
      return unknown_key;
    }
    //
    //
    // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
    // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
    // SPKI PUBLIC?
    //
    //
    try {
      key = await this.#crypto.subtle.importKey(
        "spki",
        this.base64ToArray(unknown_key),
        { name: "ECDH", namedCurve: "P-256" },
        true,
        []
      );
      return key;

    } catch(e){}
    //
    //
    // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
    // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
    // RAW PUBLIC
    //
    //
    try {
      key = await this.#crypto.subtle.importKey(
        "raw",
        this.base64ToArray(unknown_key),
        { name: "ECDH", namedCurve: "P-256" },
        true,
        []
      );
      return key;
      
    } catch(e){}
    //
    //
    // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
    // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
    // PKCS8 PRIVATE
    //
    //
    try{
      key = await this.#crypto.subtle.importKey(
        "pkcs8",
        this.base64ToArray(unknown_key),
        { name: "ECDH", namedCurve: "P-256" },
        false,
        ["deriveKey","deriveBits"]
      );
      return key;
      
    } catch(e){}
    //
    //
    // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
    // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
    // RAW PUBLIC - PERVERTED
    //
    //
    try {
      
      longKey = new Uint8Array([4].concat(Array.from(this.base64ToArray(unknown_key))));
      key = await this.#crypto.subtle.importKey(
        "raw",
        longKey,
        { name: "ECDH", namedCurve: "P-256" },
        true,
        []
      );
      return key;
      
    } catch(e){
      throw new Error("UNRECOGNIZED KEY FORMAT");
    }



  }




  // //////////////////////////////////////////////////////////////////////////
  // //////////////////////////////////////////////////////////////////////////
  //
  // Function:     EcdsaConvertKey (some sort of key)
  // What is this: Sloppy AF function to try converting random data into a key
  //               until something works...
  //
  // Arguments:    none
  //
  // Returns:      hopefully a live key...probably an error and an hour of debugging.
  // Notes:
  //
  // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
  // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
  
  EcdsaConvertKey = async (unknown_key) => {
    await this.#sleep(0);

    let key;
    let longKey;
    let err = true;
    
    
    // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
    // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
    // NATURAL KEY
    if(unknown_key instanceof this.#crypto.CryptoKey){
      return unknown_key;
    }
    
    
    //
    //
    // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
    // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
    // SPKI PUBLIC?
    //
    //
    try {
      
      key = await this.#crypto.subtle.importKey(
        "spki",
        this.base64ToArray(unknown_key),
        { name: "ECDSA", namedCurve: "P-256" },
        true,
        ["verify"]
      );
      
      return key;
      
    } catch(e){}

    //
    //
    // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
    // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
    // RAW PUBLIC
    //
    //
    try {
      
      key = await this.#crypto.subtle.importKey(
        "raw",
        this.base64ToArray(unknown_key),
        { name: "ECDSA", namedCurve: "P-256" },
        true,
        ["verify"]
      );

      return key;
      
    } catch(e){}

    //
    //
    // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
    // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
    // PKCS8 PRIVATE
    //
    //
    try{

      key = await this.#crypto.subtle.importKey(
        "pkcs8",
        this.base64ToArray(unknown_key),
        { name: "ECDSA", namedCurve: "P-256" },
        false,
        ["sign"]
      );

      return key;
      
    } catch(e){}

    //
    //
    // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
    // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
    // RAW PUBLIC - PERVERTED
    //
    //
    try {

      longKey = new Uint8Array([4].concat(Array.from(this.base64ToArray(unknown_key))));
      key = await this.#crypto.subtle.importKey(
        "raw",
        longKey,
        { name: "ECDSA", namedCurve: "P-256" },
        true,
        ["sign"]
      );

      return key;
      
    } catch(e){
      throw new Error("UNRECOGNIZED KEY FORMAT");
    }

  }

  
  
}
// \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
// \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
// \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
;// CONCATENATED MODULE: ./src/js/browser/createInitialBrowserSignature.js


/* harmony default export */ const createInitialBrowserSignature = (async (browserSignatureKeys, metadata) => {
  const ezcrypto = new EZCrypto();

  // //////////////////////////////////////////////////////////////////////////////
  //
  // 1.) THE BROWSER CREATES A PUBLIC KEY, SIGNS IT, AND SHIPS IT TO THE RP
  //
  // //////////////////////////////////////////////////////////////////////////////

  // These are the things that get signed
  let browserTimestamp = new Date().getTime().toString();
  let browserPublicKey = browserSignatureKeys.publicKey;

  // These are the signature and sig-target
  let browserData = btoa(
    JSON.stringify({
      timestamp: browserTimestamp,
      publicKey: browserPublicKey,
      metadata,
    })
  );
  let browserSignature = await ezcrypto.EcSignData(
    browserSignatureKeys.privateKey,
    browserData
  );

  return JSON.stringify({ data: browserData, signature: browserSignature });
});

;// CONCATENATED MODULE: ./src/js/browser/createFinalBrowserSignature.js


/* harmony default export */ const createFinalBrowserSignature = (async (browserSignatureKeys, rpResponse) => {
  const ezcrypto = new EZCrypto();


    // These are the things that get added and signed to prove validity
    let browserTimestamp = new Date().getTime().toString();
    let browserPublicKey = browserSignatureKeys.publicKey;

    // This is what we will end up signing
    let browserData = btoa(
      JSON.stringify({
        timestamp: browserTimestamp,
        publicKey: browserPublicKey,
        child: rpResponse,
      })
    );

    // Here's our signature
    let browserSignature = await ezcrypto.EcSignData(
      browserSignatureKeys.privateKey,
      browserData
    );

    // This is what we need to somehow hand off to mobile
    return {
      data: browserData,
      signature: browserSignature,
    };


});

;// CONCATENATED MODULE: ./src/js/browser/browser.js




class ApplessBrowser {
  /////////////////////////////////////////////////////////////////////////////
  //
  //
  /////////////////////////////////////////////////////////////////////////////
  register = async (url, metadata, password) => {

    //
    // 0.) FINE! We're using passwords for everything
    //     
    //
    if(!password){
      password = "";
    }

    const ezcrypto = new EZCrypto();
    const browserSignatureKeys = await ezcrypto.EcMakeSigKeys(false);

    //
    // 1.) THE BROWSER CREATES A PUBLIC KEY, SIGNS IT, AND SHIPS IT TO THE RP
    //
    let initialBrowserSignatureData = await createInitialBrowserSignature(
      browserSignatureKeys,
      metadata
    );

    //
    // 2.) THROUGH THE METADATA - RP LEARNS WHO USER IS. THEY RETURN A SIGNED OBJECT
    //     WITH THE USER'S REAL ID
    //
    let options = {
      method: "POST",
      headers: { "content-type": "application/json" },
      body: initialBrowserSignatureData,
    };

    let rpResponse = await fetch(url, options).then(async (data) => {
      return data.json();
    });

    //
    // 3.) BROWSER GETS IT, SIGNS IT
    //
    let returnValue = await createFinalBrowserSignature(browserSignatureKeys, rpResponse);

    //
    // 4.) NOW WE ENCRYPT IT SO IT DOESN'T GET INTERCEPTED
    //
    returnValue = btoa(JSON.stringify(returnValue));

    returnValue = await ezcrypto.PASSWORD_ENCRYPT(password, returnValue);

    console.log( {encrypted: true, data: returnValue} );

    return {encrypted: true, data: returnValue};
  };
}

;// CONCATENATED MODULE: ./node_modules/ezwebauthn/index.js
/**
 * Class to handle 
 */
 class EZWebAuthn{
	
    //
    // SIMPLE STRING-TO-buffer`
    //
    #utf8StringToBuffer = (value) => {
        return new TextEncoder().encode(value);
    }

    //
    // SIMPLE buffer-TO-STRING
    // 
    //
    #bufferToUTF8String = (value) =>  {
        return new TextDecoder('utf-8').decode(value);
    }

    //
    // ARRAYBUFFER ====> Base64
    //
    #bufferToBase64URLString = (buffer) => {
        const bytes = new Uint8Array(buffer);
        let str = '';
        for (const charCode of bytes) {
            str += String.fromCharCode(charCode);
        }
        const base64String = btoa(str);
        return base64String.replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
    }

    //
    // Base64 =====> ARRAYBUFFER
    //
    #base64URLStringToBuffer = (base64URLString) => {
        
        const base64 = base64URLString.replace(/-/g, '+').replace(/_/g, '/');
        const padLength = (4 - (base64.length % 4)) % 4;
        const padded = base64.padEnd(base64.length + padLength, '=');
        const binary = atob(padded);
        const buffer = new ArrayBuffer(binary.length);
        const bytes = new Uint8Array(buffer);
        for (let i = 0; i < binary.length; i++) {
            bytes[i] = binary.charCodeAt(i);
        }
        return buffer;
    }

    //
    // CHECK TO SEE IF THE BROWSWER SUPPORTS WEB-AUTHN
    //
    #browserSupportsWebauthn = () => {
        return ((window === null || window === void 0 ? void 0 : window.PublicKeyCredential) !== undefined && typeof window.PublicKeyCredential === 'function');
    }


    //
    // ?????????????????????
    // Convert the ID of a descriptor to base64; but retain the rest?
    //
    #toPublicKeyCredentialDescriptor = (descriptor) => {
        
        var that = this;
        
        const { id } = descriptor;
        return {
            ...descriptor,
            id: this.#base64URLStringToBuffer(id),
        };
    }


    // THROW THIS AWAY ASAP!!!
	priv = {}


    //
    // ======================================================
    // ======================================================
    // ======================================================
    // ======================================================
    //
    //
    async startRegistration(creationOptionsJSON) {

        var that = this;
        
        if (!that.#browserSupportsWebauthn()) {
            throw new Error('WebAuthn is not supported in this browser');
        }

        //
        // This builds out the options that `window.navigator` can consume
        // based on what options we feed it
        //
        let publicKey = {
            ...creationOptionsJSON,
            challenge: that.#base64URLStringToBuffer(creationOptionsJSON.challenge),
            user: {
                ...creationOptionsJSON.user,
                id: that.#utf8StringToBuffer(creationOptionsJSON.user.id),
            },
            excludeCredentials: creationOptionsJSON.excludeCredentials.map(this.#toPublicKeyCredentialDescriptor)
        };
        

        //
        // Push our options into navigator and hope that a valid credential comes out
        // the other side
        //
        const credential = (await navigator.credentials.create({ publicKey: publicKey }));

        if (!credential) {
            throw new Error('Registration was not completed');
        }

        //
        // Pull the core constituents out of the credential
        // that the navigator provided us
        //
        const { id, rawId, response, type } = credential;

        //
        // Create an "authenticator" object that we can use later
        // with binary arrays stored in base64
        //
        const credentialJSON = {
            id,
            rawId: that.#bufferToBase64URLString(rawId),
            response: {
                attestationObject: that.#bufferToBase64URLString(response.attestationObject),
                clientDataJSON: that.#bufferToBase64URLString(response.clientDataJSON),
            },
            type,
            clientExtensionResults: credential.getClientExtensionResults(),
        };

        if (typeof response.getTransports === 'function') {
            credentialJSON.transports = response.getTransports();
        }

        return credentialJSON;
    }


    //
    // ======================================================
    // ======================================================
    // ======================================================
    // ======================================================
    //
    //
    async startAuthentication(requestOptionsJSON) {
        var that = this;
        
        var _a, _b;
        if (!that.#browserSupportsWebauthn()) {
            throw new Error('WebAuthn is not supported in this browser');
        }
        
        let allowCredentials;
        if (((_a = requestOptionsJSON.allowCredentials) === null || _a === void 0 ? void 0 : _a.length) !== 0) {
            allowCredentials = (_b = requestOptionsJSON.allowCredentials) === null || _b === void 0 ? void 0 : _b.map((x) => {return this.#toPublicKeyCredentialDescriptor(x)});
        }
        const publicKey = {
            ...requestOptionsJSON,
            challenge: that.#base64URLStringToBuffer(requestOptionsJSON.challenge),
            allowCredentials,
        };

        const credential = (await navigator.credentials.get({ publicKey }));
        if (!credential) {
            throw new Error('Authentication was not completed');
        }
        const { id, rawId, response, type } = credential;
        let userHandle = undefined;
    
        if (response.userHandle) {
            userHandle = that.#bufferToUTF8String(response.userHandle);
        }
        return {
            id,
            rawId: that.#bufferToBase64URLString(rawId),
            response: {
                authenticatorData: that.#bufferToBase64URLString(response.authenticatorData),
                clientDataJSON: that.#bufferToBase64URLString(response.clientDataJSON),
                signature: that.#bufferToBase64URLString(response.signature),
                userHandle,
            },
            type,
            clientExtensionResults: credential.getClientExtensionResults(),
        };
    }
    
    //
    // ======================================================
    // ======================================================
    // ======================================================
    // ======================================================
    //
    //
    async platformAuthenticatorIsAvailable() {
        if (!browserSupportsWebauthn()) {
            return false;
        }
        return PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable();
    }

}
;// CONCATENATED MODULE: ./node_modules/ezindexdb/index.js
class EZindexDB{
  
  #database;
  #trans;

  
  // //////////////////////////////////////////////////////////////////////////
  //
  // Instantiate a connection to the database, if not just create
  // it outright.
  //
  // //////////////////////////////////////////////////////////////////////////
  start = async (database, table, indexes) => {
    return new Promise((resolve, reject) => {
      try{
        // start connection to DB, then, listen for events
        const openRequest = indexedDB.open(database, 1);

        // handle error
        openRequest.onerror = event => {reject(event)};

        // upgradeNeeded ???
        openRequest.onupgradeneeded = async event => {
          this.#database = event.target.result;
          const store = this.#database.createObjectStore(table, {"keyPath": "id"});
          
          // If we're taking indexes, let's create indexes
          if(indexes){
            let tmp = await Promise.all(indexes.map((index) => {return store.createIndex(index,index)}));
          }
        };

        openRequest.onsuccess = event => {
          this.#database = event.target.result;
          resolve(true);
        };
      } catch(err){
        reject(err);
      }
    });
  }
  // //////////////////////////////////////////////////////////////////////////
  //
  // Create a transaction that we can use internally
  //
  // //////////////////////////////////////////////////////////////////////////
  #transaction = async(table) => {
    const transaction = await this.#database.transaction(table, 'readwrite');
    const store = transaction.objectStore(table);
    return store;
  }
  
  


  // //////////////////////////////////////////////////////////////////////////
  //
  // Add a record to the database if it doesn't exist
  // THROW AN ERROR IF THE RECORD DOES EXIST
  //
  // //////////////////////////////////////////////////////////////////////////
  creates = async (table, data) => {
    
    // start a transaction
    const store = await this.#transaction(table);
    
    // store whatever comes from our method here
    let results;
    
    try{

      // Try getting some information out of the database
      results = await store.add(data);

      await new Promise((s,j) => {
      
        // Handle when everything was successful
        results.onsuccess = () => {
          return s(true);
        }

        // Handle when things went poorly...
        results.onerror = (e) => {
          throw new Error(e);
          return j(false);
        }
      
      });
      

      // Return our success now that we're done
      return results.result;

    } catch(e){
      // return our failure, now that we've failed
      return e;
    }
  }
  
  // //////////////////////////////////////////////////////////////////////////
  //
  // GET A RECORD OUT OF THE DATABASE
  //
  // //////////////////////////////////////////////////////////////////////////
  reads = async (table, id) => {
    
    // start a transaction
    const store = await this.#transaction(table);
    
    // store whatever comes from our method here
    let results;
    
    try{

      // Try getting some information out of the database
      results = await store.get(id);

      await new Promise((s,j) => {
      
        // Handle when everything was successful
        results.onsuccess = () => {
          return s(true);
        }

        // Handle when things went poorly...
        results.onerror = (e) => {
          throw new Error(e);
          return j(false);
        }
      
      });

      // Return our success now that we're done
      return results.result;

    } catch(e){
      // return our failure, now that we've failed
      return e;
    }

  }
  
  // //////////////////////////////////////////////////////////////////////////
  //
  // UPDATE A RECORD IN THE DATABASE IF IT DOES EXIST
  // THROW AN ERROR IF THE RECORD DOES EXIST
  //
  // //////////////////////////////////////////////////////////////////////////
  updates = async (table, data) => {
    
    // see if the thing exists first.
    // if not, fail it
    let test_data = await this.reads(table, data.id);
    
    if(!test_data){
      throw new Error("A record must exist before you can update it");
    }
    
    // start a transaction
    const store = await this.#transaction(table);
    
    // store whatever comes from our method here
    let results;
    
    try{

      // Try getting some information out of the database
      results = await store.put(data);

      await new Promise((s,j) => {
      
        // Handle when everything was successful
        results.onsuccess = () => {
          return s(true);
        }

        // Handle when things went poorly...
        results.onerror = (e) => {
          throw new Error(e);
          return j(false);
        }
      
      });
      

      // Return our success now that we're done
      return results.result;

    } catch(e){
      // return our failure, now that we've failed
      return e;
    }
  }
  
  // //////////////////////////////////////////////////////////////////////////
  //
  // UPDATE A RECORD IN THE DATABASE IF IT DOES EXIST
  // THROW AN ERROR IF THE RECORD DOES EXIST
  //
  // //////////////////////////////////////////////////////////////////////////
  deletes = async (table, id) => {
    
    
    // start a transaction
    const store = await this.#transaction(table);
    
    // store whatever comes from our method here
    let results;
    
    try{

      // Try getting some information out of the database
      results = await store.delete(id);

      await new Promise((s,j) => {
      
        // Handle when everything was successful
        results.onsuccess = () => {
          return s(true);
        }

        // Handle when things went poorly...
        results.onerror = (e) => {
          throw new Error(e);
          return j(false);
        }
      
      });
      

      // Return our success now that we're done
      return results.result;

    } catch(e){
      // return our failure, now that we've failed
      return e;
    }
  }
  
  
  
  
  
  // //////////////////////////////////////////////////////////////////////////
  //
  // GET A RECORD OUT OF THE DATABASE - BY FIELD / VALUE COMBO...
  //
  // //////////////////////////////////////////////////////////////////////////
  searches = async (table, field, value) => {
    
    // start a transaction
    const store = await this.#transaction(table);
    
    // store whatever comes from our method here
    let results;
    
    try{

      // Set Reference to our Index
      let ndx = store.index(field);
      
      results = await ndx.getAll(value);

      await new Promise((s,j) => {
      
        // Handle when everything was successful
        results.onsuccess = () => {
          return s(true);
        }

        // Handle when things went poorly...
        results.onerror = (e) => {
          console.log({e});
          throw new Error(e);
          return j(false);
        }
      
      });

      // Return our success now that we're done
      return results.result;

    } catch(e){
      // return our failure, now that we've failed
      return e;
    }

  }
  
}

/////////////////////////////////
// DEMO:
/////////////////////////////////

/*
// Instantiate the DB
  let ez = new EZindexDB();
  
//
// List any of the fields we might want to search on
// that aren't "id"
//
  await ez.start("company","people",["name"]);

//
// Demonstration of adding people to our DB
//
  await ez.creates("people",{"id": "1", "salary": 12, "name": "STEVE"});
  await ez.creates("people",{"id": "2", "salary": 12, "name": "EDDY"});
  await ez.creates("people",{"id": "3", "salary": 12, "name": "JOE"});
  await ez.creates("people",{"id": "4", "salary": 13, "name": "JOE"});

//
// Find everybody named "JOE"
//
  let data = await ez.searches("people","name", "JOE");
  
//
// Set Joe's Salary to 12_000
//
  await ez.updates("people",{"id": "3", "salary": 12_000});
  
//
// Make sure we can't 'upsert' a record
//
  await ez.updates("people",{"id": "newb", "salary": 12_000});  // this one fails
*/


;// CONCATENATED MODULE: ./src/js/mobile/getKeys.mjs




async function getKeys(){
    
    let database = new EZindexDB()
    let crypto = new EZCrypto();
    let signingKeys;
    let encryptionKeys;

    // Instantiate our connection to the database;
    await database.start('mobile', 'credentials')

    // GET THE KEYS OUT OF THE DATABASE IF THEY ALREADY EXIST
    try {
        signingKeys = await database.reads('credentials', 'signingKeys')
        encryptionKeys = await database.reads('credentials', 'encryptionKeys')
    } catch (e) {
        throw new Error(e);
    }

    // IF THEY DON'T EXIST, CREATE THEM AND STORE THEM IN THE DB
    if (typeof signingKeys == 'undefined') {
        signingKeys = await crypto.EcMakeSigKeys(false)
        signingKeys.id = 'signingKeys'

        encryptionKeys = await crypto.EcMakeCryptKeys(false)
        encryptionKeys.id = 'encryptionKeys'

        try {
            await database.creates('credentials', signingKeys)
            await database.creates('credentials', encryptionKeys)
        } catch (e) {
            throw new Error(e);
        }
    }
    return {signingKeys, encryptionKeys};
}
;// CONCATENATED MODULE: ./src/js/mobile/getSessionData.mjs
async function getSessionData(publicKey, env) {
    let sessionData
    let userParameters
    //
    // Pull the session ID off the URL we're on
    //
    let queryStringData = Object.fromEntries(Array.from(new URL(document.location).searchParams))

    let sessionId = queryStringData.sessionId

    if (!sessionId) {
        throw new Error('No Session Id Provided')
    }
    //
    // Use headers to communicate with the API so they know who
    // we are...
    //
    let headers = new Headers({
        'x-mobile-id': publicKey,
    })

    //
    // Options for loading
    //
    let opts = { mode: 'cors', method: 'GET', headers }

    //
    // THIS IS THE STANDARD KEYRI-REST-GET API CALL...
    //
    let url = `https://${env}.api.keyri.com/api/v1/session/${sessionId}`

    sessionData = await fetch(url, opts)

    if (sessionData?.ok === false) {
        sessionData = await sessionData.json()
        throw new Error(sessionData.message)
    } else {
        sessionData = await sessionData.json()
    }

    //
    // We're ASSUMING this is what's being sent back by our API
    //
    userParameters = atob(sessionData?.userParameters?.base64EncodedData)
    userParameters = JSON.parse(userParameters)

    return { sessionData, userParameters, sessionId }
}

;// CONCATENATED MODULE: ./src/js/mobile/postSessionData.mjs


async function postSessionData(data, myPrivateKey, myPublicKey, sessionData, sessionId, env) {
    //
    // 0.) Instantiate EZCrypto
    //
    const crypto = new EZCrypto();

    //
    // 1.) Encrypt some data
    //
    let encryptionData = await crypto.HKDFEncrypt(myPrivateKey, sessionData.browserPublicKey, btoa(JSON.stringify(data)))

    //
    // 2.) Build out the POST object
    //
    let postBody = {
        apiData: {
            associationKey: 'WEBSOCKET-TEST-SCRIPT',
            publicUserId: 'public-User-ID',
        },
        browserData: {
            ...encryptionData,
            publicKey: myPublicKey,
        },
        errorMsg: '',
        errors: false,
    }

    //
    // 3.) Add to the POST body, with salt and hash
    //
    let postOpts = {
        mode: 'cors',
        method: 'POST',
        body: JSON.stringify({
            ...postBody,
            __salt: sessionData.__salt,
            __hash: sessionData.__hash,
        }),
    }

    //
    // 4.) ...SEND IT
    //
    let postData = await fetch(`https://${env}.api.keyri.com/api/v1/session/${sessionId}`, postOpts).then(
        async (data) => {
            return await data.json()
        }
    )

    window.close()
}

;// CONCATENATED MODULE: ./src/js/mobile/authUser.mjs



async function authUser(userParameters, keys, sessionId, sessionData, env, local) {

    //
    // 0.) Instantiate Crypto
    //
    const crypto = new EZCrypto();

    //
    // 1.) Generic Auth Options
    //
    let data = btoa(JSON.stringify({ timestamp: new Date().getTime(), publicKey: keys.signingKeys.publicKey }))
    let signature = await crypto.EcSignData(keys.signingKeys.privateKey , data)
    let challenge = btoa(JSON.stringify({ data, signature, publicKey: keys.signingKeys.publicKey }))

    let authoptions = {
        challenge,
        rpId: document.location.host,
        userVerification: 'discouraged',
        timeout: 60000,
        requireResidentKey: true,
    }

    //
    // 2.) WebAuthn Get Auth
    //
    window.focus()
    const ezwebauthn = new EZWebAuthn()
    const authenticatorData = await ezwebauthn.startAuthentication(authoptions)

    //
    // 3.) Verify it with the API
    //
    let output = await fetch('https://c4xfkg8ea4.execute-api.us-east-2.amazonaws.com/prod/v1/browser/verify/', {
        method: 'POST',
        mode: 'cors',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify(authenticatorData),
    }).then(async (data) => {
        return await data.json()
    })

    //
    // Return whatever we got from the API
    //
    if (!local) {
        //
        // Inform the developwer the type of operation is appless
        //
        output.validationFormat = 'keyri-appless'

        await postSessionData(
            output,
            keys.encryptionKeys.privateKey,
            keys.encryptionKeys.publicKey,
            sessionData,
            sessionId,
            env
        )
    } else {
        return output
    }
}

;// CONCATENATED MODULE: ./src/js/mobile/index.js








// ////////////////////////////////////////////////////////////////////////////
// ////////////////////////////////////////////////////////////////////////////
//
//
// ////////////////////////////////////////////////////////////////////////////
// ////////////////////////////////////////////////////////////////////////////
class ApplessMobile {
    #database;
    #env;
    #sessionId;
    #radio;
    #local = false;
    #crypto;
    #sessionData;
    #passwordHandler;
    #keys = {
        signingKeys: {},
        encryptionKeys: {},
    };


    /////////////////////////////////////////////////////////////////////////////
    //
    //
    /////////////////////////////////////////////////////////////////////////////
    constructor(env) {
        this.#env = env
        this.#database = new EZindexDB()
        this.#crypto = new EZCrypto()
        this.#radio = document.createDocumentFragment()
    }

    // //////////////////////////////////////////////////////////////////////////
    // //////////////////////////////////////////////////////////////////////////
    // //////////////////////////////////////////////////////////////////////////
    //
    on = (t, e) => {
        this.#radio.addEventListener(t, e)
    }

    // //////////////////////////////////////////////////////////////////////////
    // //////////////////////////////////////////////////////////////////////////
    // //////////////////////////////////////////////////////////////////////////
    // Internal method to broadcast custom events when needed
    //
    #broadcast = (t, e) => {
        this.#radio.dispatchEvent(
            new CustomEvent(t, {
                detail: e,
            })
        )
    }

    /////////////////////////////////////////////////////////////////////////////
    //
    //
    /////////////////////////////////////////////////////////////////////////////
    register = async (registrationData = false) => {
        return await this.#registerUser({ registration: registrationData })
    }

    /////////////////////////////////////////////////////////////////////////////
    //
    //
    /////////////////////////////////////////////////////////////////////////////
    authenticate = async () => {
        try{
            return await authUser();
        } catch(e){
            console.log({ERROR: e});
        }
    }

    /////////////////////////////////////////////////////////////////////////////
    //
    // This is a function the dev provides. IF we need a password, this is the function
    // that is called to retrieve it from the user
    //
    /////////////////////////////////////////////////////////////////////////////
    set passwordHandler(fx) {
        this.#passwordHandler = fx
    }

    /////////////////////////////////////////////////////////////////////////////
    //
    //
    /////////////////////////////////////////////////////////////////////////////
    start = async (local = false) => {
        this.#local = local
        const { signingKeys, encryptionKeys } = await getKeys()

        this.#keys.signingKeys = signingKeys
        this.#keys.encryptionKeys = encryptionKeys

        if (!this.#local) {

            const { sessionData, sessionId, userParameters } = await getSessionData(signingKeys.publicKey, this.#env);
            this.#sessionId = sessionId;
            this.#sessionData = sessionData;

            if (userParameters?.register == 'true') {
                return await this.#registerUser(userParameters)
            } else {
                try{
                    return await authUser(userParameters, this.#keys, sessionId, sessionData, this.#env, local);
                } catch(e){
                    console.log({ERROR: e});
                }

            }
        }
    }

    /////////////////////////////////////////////////////////////////////////////
    //
    //
    /////////////////////////////////////////////////////////////////////////////
    #registerUser = async (userParameters) => {
        let encrypted = userParameters.registration
        let password

        // If the dev provided a way to get a password from the user, use it
        // otherwise just assume there's a blank password
        if (!this.#passwordHandler) {
            password = ''
        } else {
            password = await this.#passwordHandler()
        }

        // either way, lets try decrypting it
        try {
            userParameters.registration = await this.#crypto.PASSWORD_DECRYPT(password, encrypted.data)
        } catch (e) {
            console.log('DATA DECRYPTION FAILED. WOMP WOMP!', { e })
            throw new Error('PASSWORD DECRYPTION FAILED.')
        }
        //
        // Back to normal
        //
        let registration = JSON.parse(userParameters.registration)
        let browserTwo = JSON.parse(atob(registration.data))
        let rpData = JSON.parse(atob(browserTwo.child.data))
        let browserData = JSON.parse(atob(rpData.child.data))

        // Build the data for mobile to sign
        let mobileData = {
            child: registration,
            publicKey: this.#keys.signingKeys.publicKey,
            timestamp: new Date().getTime(),
        }

        mobileData = btoa(JSON.stringify(mobileData))

        // Sign the data with our mobile key
        let mobileSignature = await this.#crypto.EcSignData(this.#keys.signingKeys.privateKey, mobileData)

        let mobileOut = JSON.stringify({ data: mobileData, signature: mobileSignature })

        console.log({ userParameters, mobileData, browserTwo, rpData, browserData })

        // base64 our mobile data in the normal structure
        userParameters.registration = btoa(mobileOut)

        let authoptions = {
            challenge: userParameters.registration,
            rp: {
                name: rpData.origin,
                id: rpData.origin,
            },
            user: {
                id: rpData.userId,
                name: rpData.userDisplayName,
                displayName: rpData.userDisplayName,
            },
            pubKeyCredParams: [
                {
                    alg: -7,
                    type: 'public-key',
                },
                {
                    alg: -257,
                    type: 'public-key',
                },
            ],
            timeout: 60000,
            attestation: 'none',
            excludeCredentials: [],
            authenticatorSelection: {
                requireResidentKey: true,
                userVerification: 'discouraged',
            },
        }

        return await this.#webauthRegister({ authoptions, userParameters })
    }
    /////////////////////////////////////////////////////////////////////////////
    //
    //
    /////////////////////////////////////////////////////////////////////////////
    #webauthRegister = async (data) => {
        //
        // Do Client Side WebAuthn
        //
        const ezwebauthn = new EZWebAuthn()

        window.focus()
        let userParameters = data.userParameters
        let authoptions = data?.authoptions
        let authenticatorData = await ezwebauthn.startRegistration(authoptions)

        console.log({ passKey: authenticatorData })

        let output = await fetch('https://c4xfkg8ea4.execute-api.us-east-2.amazonaws.com/prod/v1/browser/register/', {
            method: 'POST',
            mode: 'cors',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                authenticatorData,
                userParameters,
            }),
        }).then(async (data) => {
            return await data.json()
        })

        //
        // Return whatever we got from the API
        //
        if (!this.#local) {
            await postSessionData(
                output,
                this.#keys.encryptionKeys.privateKey,
                this.#keys.encryptionKeys.publicKey,
                this.#sessionData,
                this.#sessionId,
                this.#env
            );
        } else {
            return output
        }
    }


    
}

;// CONCATENATED MODULE: ./src/js/browser/index.js



class ApplessLocal {

    #browser;
    #mobile;

    #RP_REGISTER_API_URL;
    #RP_VALIDATE_API_URL;
    #VERIFICATION_CALLBACK;

  /////////////////////////////////////////////////////////////////////////////
  //
  //
  /////////////////////////////////////////////////////////////////////////////
    constructor(RP_REGISTER_API_URL, RP_VALIDATE_API_URL, VERIFICATION_CALLBACK){

      //
      // We'll need these later to register / validate the user's requests
      //
        this.#RP_REGISTER_API_URL = RP_REGISTER_API_URL;
        this.#RP_VALIDATE_API_URL = RP_VALIDATE_API_URL;
        this.#VERIFICATION_CALLBACK = VERIFICATION_CALLBACK;

        this.#browser = new ApplessBrowser();
        this.#mobile = new ApplessMobile();

    }

  /////////////////////////////////////////////////////////////////////////////
  //
  // REGISTER YOUR LOCAL DEVICE
  //
  /////////////////////////////////////////////////////////////////////////////
    register = async (METADATA) => {

      if(!METADATA){
        throw new Error("Second Argument (METADATA) Cannot Be Blank! RP Needs Some Way To Identify Who Is Making Request.");
      }

      //
      // Start the mobile script to expose its methods locally
      //
      await this.#mobile.start(true);
      
      // Back and forth between the browser and RP and Browser
      const registrationData = await this.#browser.register(this.#RP_REGISTER_API_URL, METADATA);
      
      // Perform the actual webauth stuff here...
      const mobileData = await this.#mobile.register(registrationData);

      return mobileData;

    }

  /////////////////////////////////////////////////////////////////////////////
  //
  // AUTHENTICATE LOCALLY
  //
  /////////////////////////////////////////////////////////////////////////////
    authenticate = async () => {

      await this.#mobile.start(true);
    
      const mobileData = await this.#mobile.authenticate();

      return mobileData;

    }



  /////////////////////////////////////////////////////////////////////////////
  //
  // REGISTER YOUR MOBILE-DEVICE
  //
  /////////////////////////////////////////////////////////////////////////////
  registerMobile = (METADATA, PASSWORD) => {

    //
    // Reload the IFRAME with new ARGS via its src attr
    //
    let iFrameArgs = Object.fromEntries(
      Array.from(new URL(document.location).searchParams)
    );

    iFrameArgs.register = true;
    iFrameArgs.RP_API_URL = this.#RP_REGISTER_API_URL;
    iFrameArgs.METADATA = METADATA;

    if(PASSWORD){
      iFrameArgs.PASSWORD = PASSWORD;
    }

    let queryString = new URLSearchParams(iFrameArgs);

    return queryString;
  }


  /////////////////////////////////////////////////////////////////////////////
  //
  // RP TO VALIDATE DATA
  //
  /////////////////////////////////////////////////////////////////////////////
  rp_validate_data = async (data) => {

    let options = {
      method: "POST",
      headers: { "content-type": "application/json" },
      body: JSON.stringify(data),
    };

    let rpResponse = await fetch(this.#RP_VALIDATE_API_URL, options).then(async (data) => {
      return data.json();
    });

    return await this.#VERIFICATION_CALLBACK(rpResponse);

  }
}

;// CONCATENATED MODULE: ./src/index.js





/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=index.min.js.map